!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
If you have any doubts do not proceed to generating the code before asking me.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

=================
Folder Structure:
=================
client-app/
├── config.py
├── flask_backup.py
├── flask_backup.txt
├── flask_restore.py
├── manage.py
├── logs/
│   ├── pipeline.log
├── project/
│   ├── __init__.py
│   ├── client_app/
│   │   ├── error_handlers.py
│   │   ├── __init__.py
│   │   ├── file_utils/
│   │   │   ├── file_handlers.py
│   │   │   ├── hash_utils.py
│   │   │   ├── __init__.py
│   │   ├── operations/
│   │   │   ├── cleanup_operations.py
│   │   │   ├── file_operations.py
│   │   │   ├── metadata_handler.py
│   │   │   ├── upload_handler.py
│   │   │   ├── __init__.py
│   │   │   ├── processing/
│   │   │   │   ├── cleanup_handler.py
│   │   │   │   ├── completion_handler.py
│   │   │   │   ├── core_processor.py
│   │   │   │   ├── file_processor.py
│   │   │   │   ├── file_rename.py
│   │   │   │   ├── status_tracker.py
│   │   │   │   ├── __init__.py
│   │   ├── routes/
│   │   │   ├── cleanup_routes.py
│   │   │   ├── history_routes.py
│   │   │   ├── main_routes.py
│   │   │   ├── __init__.py
│   │   │   ├── upload/
│   │   │   │   ├── hash_controller.py
│   │   │   │   ├── upload_controller.py
│   │   │   │   ├── verification_controller.py
│   │   │   │   ├── __init__.py
│   │   ├── utils/
│   │   │   ├── cleanup_utils.py
│   │   │   ├── directory_utils.py
│   │   │   ├── file_utils.py
│   │   │   ├── format_utils.py
│   │   │   ├── path_utils.py
│   │   │   ├── __init__.py
│   ├── static/
│   │   ├── css/
│   │   │   ├── bootstrap.min.css
│   │   │   ├── bootstrap.min.css.map
│   │   │   ├── custom.css
│   │   │   ├── history.css
│   │   ├── js/
│   │   │   ├── chunked-upload.js
│   │   │   ├── components/
│   │   │   │   ├── DeleteConfirmationModal.js
│   │   │   ├── core/
│   │   │   │   ├── utils.js
│   │   │   ├── file-processing/
│   │   │   │   ├── cancellation-handler.js
│   │   │   │   ├── completion-handler.js
│   │   │   │   ├── error-handler.js
│   │   │   │   ├── hash-calculator.js
│   │   │   │   ├── index.js
│   │   │   │   ├── processor.js
│   │   │   │   ├── state.js
│   │   │   │   ├── uploader.js
│   │   │   ├── handlers/
│   │   │   │   ├── delete-handlers.js
│   │   │   │   ├── form-handlers.js
│   │   │   │   ├── history-handlers.js
│   │   │   │   ├── modal-handlers.js
│   │   │   ├── lib/
│   │   │   │   ├── bootstrap/
│   │   │   │   │   ├── bootstrap.bundle.min.js
│   │   │   │   │   ├── bootstrap.bundle.min.js.map
│   │   │   │   ├── bootstrap-icons/
│   │   │   │   │   ├── bootstrap-icons.css
│   │   │   │   ├── jquery/
│   │   │   │   │   ├── jquery-3.6.0.js
│   │   │   │   │   ├── jquery-3.6.0.min.js
│   │   │   │   │   ├── jquery.min.js
│   │   │   ├── modal-handlers/
│   │   │   │   ├── confirmation-modal.js
│   │   │   │   ├── index.js
│   │   │   │   ├── modal-completion.js
│   │   │   │   ├── progress-modal.js
│   │   │   │   ├── state.js
│   │   │   ├── modules/
│   │   │   │   ├── app-state.js
│   │   │   │   ├── config.js
│   │   │   │   ├── event-handlers.js
│   │   │   │   ├── file-renaming.js
│   │   │   │   ├── form-validator.js
│   │   │   │   ├── main.js
│   │   │   │   ├── submission-handler.js
│   ├── templates/
│   │   ├── 404.html
│   │   ├── 500.html
│   │   ├── base.html
│   │   ├── history.html
│   │   ├── home.html
│   ├── tmp/
├── tmp/

File Contents:
==============

config.py
=========
import os

# User-configurable settings
UPLOAD_FOLDER = r"H:\Upload_test"
MAX_FILE_SIZE_GB = 100
SYSTEM_NAME = "System A"
STATIC_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static')

# Derived settings
MAX_FILE_SIZE = MAX_FILE_SIZE_GB * 1024 * 1024 * 1024  # Convert GB to bytes

class Config:
    UPLOAD_FOLDER = UPLOAD_FOLDER
    MAX_FILE_SIZE = MAX_FILE_SIZE
    SYSTEM_NAME = SYSTEM_NAME
    STATIC_FOLDER = STATIC_FOLDER

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

# Configuration dictionary
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}

# Allow overriding settings with environment variables
for key in ['UPLOAD_FOLDER', 'MAX_FILE_SIZE', 'SYSTEM_NAME', 'STATIC_FOLDER']:
    if os.environ.get(key):
        setattr(Config, key, os.environ.get(key))
        if key == 'MAX_FILE_SIZE':
            Config.MAX_FILE_SIZE = int(Config.MAX_FILE_SIZE)


flask_restore.py
================
import os
import re
print("Current Working Directory:", os.getcwd())
def restore_files_from_backup(backup_file_path, base_dir):
    """
    Extracts each file from the backup file and restores it to its specified folder structure.
    Logs each restored file in the terminal.

    Parameters:
    - backup_file_path (str): Path to the backup text file containing all code files.
    - base_dir (str): Base directory where the folder structure should be recreated.
    
    Returns:
    - None
    """
    # Open the backup file and read its contents
    with open(backup_file_path, 'r') as f:
        content = f.read()

    # Regex pattern to capture each file's content and its path in the structure
    file_pattern = r'([a-zA-Z0-9_/\\]+\.py)\n=+\n(.*?)\n(?=[a-zA-Z0-9_/\\]+\.py|\Z)'
    matches = re.findall(file_pattern, content, re.DOTALL)

    for file_path, file_content in matches:
        # Create the full path for each file in the base directory
        full_path = os.path.join(base_dir, file_path.replace('\\', '/'))
        dir_path = os.path.dirname(full_path)

        # Ensure the directory exists
        os.makedirs(dir_path, exist_ok=True)

        # Write the content to the file
        with open(full_path, 'w') as file:
            file.write(file_content)
        
        # Log the restored file in the terminal
        print(f"Updated: {full_path}")

# Usage example
restore_files_from_backup(r'c:\Users\phillipb\Desktop\Pipeline\client-app\flask_backup.txt', 'client-app')


manage.py
=========
from project import create_app

app = create_app()

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=5000, debug=True)


project\__init__.py
===================
from flask import Flask
from logging.handlers import RotatingFileHandler
import logging
import os
from config import config

def create_app(config_name='default'):
    app = Flask(__name__)

    # Load the configuration
    app.config.from_object(config[config_name])

    # Configure logging
    if not app.debug:
        if not os.path.exists('logs'):
            os.mkdir('logs')
        file_handler = RotatingFileHandler('logs/pipeline.log', maxBytes=10240, backupCount=10)
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
        ))
        file_handler.setLevel(logging.INFO)
        app.logger.addHandler(file_handler)
        app.logger.setLevel(logging.INFO)
        app.logger.info('Pipeline startup')

    # Register Blueprints
    from .client_app import client_app
    app.register_blueprint(client_app)

    return app


project\client_app\error_handlers.py
====================================
# project/client_app/error_handlers.py

from flask import jsonify, render_template, request, current_app
from werkzeug.exceptions import HTTPException

def register_error_handlers(app):
    """Registers error handlers with the Flask app instance."""

    @app.errorhandler(404)
    def not_found_error(error):
        """Handle 404 errors."""
        if request.path.startswith('/static/'):
            return "File not found", 404
        return render_template('404.html'), 404

    @app.errorhandler(500)
    def internal_error(error):
        """Handle 500 errors."""
        current_app.logger.error(f"500 error: {str(error)}")
        return jsonify({
            'error': 'Internal server error',
            'message': str(error)
        }), 500

    @app.errorhandler(Exception)
    def handle_exception(e):
        """Handle unhandled exceptions."""
        if isinstance(e, HTTPException):
            return e
        current_app.logger.error(f"Unhandled exception: {str(e)}", exc_info=True)
        return jsonify({
            'error': 'Internal Server Error',
            'message': str(e)
        }), 500


project\client_app\__init__.py
==============================
# project/client_app/__init__.py
"""Client application package - initializes blueprints and error handlers."""

from flask import Blueprint

# Create the main blueprint
client_app = Blueprint(
    'client_app',
    __name__,
    template_folder='../templates',
    static_folder='../static'
)

# Import route modules
from .routes.main_routes import main_routes
from .routes.upload import create_upload_blueprint
from .routes.cleanup_routes import cleanup_routes
from .routes.history_routes import history_routes

# Register route modules
client_app.register_blueprint(main_routes)
client_app.register_blueprint(create_upload_blueprint())
client_app.register_blueprint(cleanup_routes)
client_app.register_blueprint(history_routes)

# Import error handlers
from . import error_handlers

# Register error handlers
error_handlers.register_error_handlers(client_app)


project\client_app\file_utils\file_handlers.py
==============================================
# project/client_app/file_utils/file_handlers.py
"""Core file handling utilities."""

import os
import time
from typing import Tuple, Dict
from flask import current_app
from werkzeug.utils import secure_filename
from .hash_utils import calculate_file_hash, verify_file_integrity

def check_existing_file(filepath: str) -> bool:
    """
    Check if a file already exists at the given path.
    
    Args:
        filepath (str): Path to check
        
    Returns:
        bool: True if file exists, False otherwise
    """
    return os.path.exists(filepath)

def get_final_filename(original_filename: str, rename_checked: bool, rename_preview: str) -> str:
    """
    Determine the final filename based on rename settings.
    
    Args:
        original_filename (str): Original file name
        rename_checked (bool): Whether rename option is checked
        rename_preview (str): Preview of new filename if rename is checked
        
    Returns:
        str: Final filename to use
    """
    if rename_checked and rename_preview:
        base, ext = os.path.splitext(rename_preview)
        return f"{base}_complete{ext}"
    else:
        base, ext = os.path.splitext(original_filename)
        return f"{base}_complete{ext}"

def handle_file_processing(
    filepath: str,
    final_path: str,
    metadata: Dict,
    rename_checked: bool = False,
    rename_preview: str = ""
) -> Tuple[bool, str, Dict]:
    """
    Process file with integrity checks and proper renaming.
    
    Args:
        filepath (str): Path to the current file
        final_path (str): Path where the file should end up
        metadata (Dict): File metadata dictionary
        rename_checked (bool): Whether rename option is checked
        rename_preview (str): Preview of new filename if rename is checked
        
    Returns:
        Tuple[bool, str, Dict]: (success, error_message, updated_metadata)
    """
    try:
        current_app.logger.info(f"Starting file processing for: {filepath}")

        if not os.path.exists(filepath):
            return False, f"Source file not found: {filepath}", metadata

        current_app.logger.info("Calculating original file hash...")
        original_hash = calculate_file_hash(filepath)
        metadata['originalFileHash'] = original_hash
        current_app.logger.info(f"Original file hash: {original_hash}")

        final_filename = get_final_filename(
            os.path.basename(filepath),
            rename_checked,
            rename_preview
        )
        
        final_path = os.path.join(os.path.dirname(final_path), final_filename)

        if os.path.exists(final_path):
            return False, f"Destination file already exists: {final_filename}", metadata

        current_app.logger.info(f"Renaming file to: {final_filename}")
        
        try:
            os.rename(filepath, final_path)
        except OSError as e:
            return False, f"Error renaming file: {str(e)}", metadata

        current_app.logger.info("Calculating final file hash...")
        final_hash = calculate_file_hash(final_path)
        metadata['finalFileHash'] = final_hash
        current_app.logger.info(f"Final file hash: {final_hash}")

        if original_hash != final_hash:
            current_app.logger.error("Hash mismatch detected!")
            try:
                os.rename(final_path, filepath)
            except OSError:
                pass
            return False, "File integrity check failed - hashes do not match", metadata

        metadata['final_filename'] = final_filename
        metadata['file_verified'] = True

        current_app.logger.info("File processing completed successfully")
        return True, "", metadata

    except Exception as e:
        current_app.logger.error(f"Error in handle_file_processing: {str(e)}")
        return False, f"Error processing file: {str(e)}", metadata

def get_file_size(filepath: str) -> int:
    """
    Get file size in bytes.
    
    Args:
        filepath (str): Path to the file
        
    Returns:
        int: File size in bytes
    """
    try:
        return os.path.getsize(filepath)
    except OSError as e:
        current_app.logger.error(f"Failed to get file size for {filepath}: {str(e)}")
        raise

def clean_directory(directory: str, exclude_files: list = None) -> None:
    """Clean a directory with enhanced error handling"""
    exclude_files = exclude_files or []
    try:
        for filename in os.listdir(directory):
            if filename not in exclude_files:
                filepath = os.path.join(directory, filename)
                if os.path.isfile(filepath):
                    try:
                        os.remove(filepath)
                        current_app.logger.info(f"Removed file: {filepath}")
                    except PermissionError:
                        current_app.logger.warning(f"Permission denied when trying to remove: {filepath}")
                        # Wait briefly and try again
                        time.sleep(1)
                        try:
                            os.remove(filepath)
                            current_app.logger.info(f"Successfully removed file on second attempt: {filepath}")
                        except Exception as e:
                            current_app.logger.error(f"Failed to remove file even after retry: {filepath}, Error: {str(e)}")
    except Exception as e:
        current_app.logger.error(f"Failed to clean directory {directory}: {str(e)}")
        raise

def is_valid_file_type(filename: str, allowed_extensions: list = None) -> bool:
    """
    Check if file has an allowed extension.
    
    Args:
        filename (str): Name of the file to check
        allowed_extensions (list): List of allowed extensions
        
    Returns:
        bool: True if file type is allowed, False otherwise
    """
    if not allowed_extensions:
        allowed_extensions = current_app.config.get('ALLOWED_EXTENSIONS', [])
    
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in allowed_extensions

def format_file_size(size_in_bytes: int) -> str:
    """
    Format file size in human-readable format.
    
    Args:
        size_in_bytes (int): File size in bytes
        
    Returns:
        str: Formatted file size string (e.g., "1.5 MB")
    """
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_in_bytes < 1024.0:
            return f"{size_in_bytes:.2f} {unit}"
        size_in_bytes /= 1024.0
    return f"{size_in_bytes:.2f} PB"


project\client_app\file_utils\hash_utils.py
===========================================
# project/client_app/file_utils/hash_utils.py
"""Utilities for file hashing and verification."""

import os
import hashlib
from flask import current_app

def calculate_file_hash(filepath: str, chunk_size: int = 8192) -> str:
    """
    Calculate MD5 hash of a file in chunks with enhanced progress tracking
    """
    md5_hash = hashlib.md5()
    total_size = os.path.getsize(filepath)
    bytes_processed = 0
    last_progress = 0
    
    current_app.logger.info(f"Starting MD5 hash calculation for file: {filepath}")
    
    with open(filepath, "rb") as f:
        for byte_block in iter(lambda: f.read(chunk_size), b""):
            md5_hash.update(byte_block)
            bytes_processed += len(byte_block)
            
            # Calculate progress percentage
            progress = int((bytes_processed / total_size) * 100)
            
            # Log progress every 5% change
            if progress >= last_progress + 5:
                current_app.logger.info(f"Hash calculation progress: {progress}%")
                last_progress = progress
                
    hash_result = md5_hash.hexdigest()
    current_app.logger.info(f"MD5 hash calculation completed: {hash_result}")
    return hash_result

def verify_file_integrity(src_hash: str, dst_path: str) -> bool:
    """
    Verify file integrity by comparing hashes.
    
    Args:
        src_hash (str): Original file hash
        dst_path (str): Path to the file to verify
        
    Returns:
        bool: True if hashes match, False otherwise
    """
    try:
        dst_hash = calculate_file_hash(dst_path)
        return src_hash == dst_hash
    except Exception as e:
        current_app.logger.error(f"Error verifying file integrity: {str(e)}")
        return False


project\client_app\file_utils\__init__.py
=========================================
# project/client_app/file_utils/__init__.py
"""File utilities package providing file operation capabilities."""

from .hash_utils import calculate_file_hash, verify_file_integrity
from .file_handlers import (
    check_existing_file,
    get_final_filename,
    handle_file_processing,
    get_file_size,
    clean_directory,
    is_valid_file_type,
    format_file_size
)

__all__ = [
    'calculate_file_hash',
    'verify_file_integrity',
    'check_existing_file',
    'get_final_filename',
    'handle_file_processing',
    'get_file_size',
    'clean_directory',
    'is_valid_file_type',
    'format_file_size'
]


project\client_app\operations\cleanup_operations.py
===================================================
# project/client_app/operations/cleanup_operations.py
from flask import current_app
import os
import shutil

class CleanupOperations:
    @staticmethod
    def cancel_upload(folder_name, base_upload_folder):
        """Handle upload cancellation and cleanup"""
        if not base_upload_folder:
            return {'error': 'Upload folder not configured'}, 500

        folder_path = os.path.join(base_upload_folder, folder_name)
        current_app.logger.info(f"Attempting to delete folder: {folder_path}")
        
        if not os.path.exists(folder_path):
            current_app.logger.info(f"Folder not found: {folder_path}")
            return {'status': 'success', 'message': 'Folder not found'}, 200

        try:
            shutil.rmtree(folder_path)
            current_app.logger.info(f"Successfully deleted folder: {folder_path}")
            return {'status': 'success', 'message': 'Upload cancelled and folder deleted'}, 200
        except Exception as e:
            current_app.logger.error(f"Error deleting folder: {str(e)}")
            return {'error': f'Error deleting folder: {str(e)}'}, 500


project\client_app\operations\file_operations.py
================================================
# project/client_app/operations/file_operations.py

from flask import current_app, request
import json
import os
import sys
from threading import Lock
import time
from typing import Dict, Any, Optional
from ..utils import get_metadata_path, find_metadata_file, ensure_dir_exists
from ..file_utils import handle_file_processing
from .upload_handler import UploadHandler
from .metadata_handler import MetadataHandler
from .processing import FileProcessor

class FileOperations:
    _processing_lock = Lock()
    _active_uploads: Dict[str, Dict[str, Any]] = {}
    _chunk_locks: Dict[str, Lock] = {}
    
    @classmethod
    def _get_chunk_lock(cls, filepath: str) -> Lock:
        """Get or create a lock for a specific file."""
        if filepath not in cls._chunk_locks:
            cls._chunk_locks[filepath] = Lock()
        return cls._chunk_locks[filepath]

    @classmethod
    def _release_resources(cls, upload_id: str, filepath: Optional[str] = None):
        """Release all resources associated with an upload."""
        try:
            if upload_id in cls._active_uploads:
                cls._active_uploads.pop(upload_id)
            if filepath and filepath in cls._chunk_locks:
                cls._chunk_locks.pop(filepath)
        except Exception as e:
            current_app.logger.error(f"Error releasing resources: {str(e)}")

    @classmethod
    def _ensure_upload_dir(cls, filepath: str) -> None:
        """Ensure the upload directory exists."""
        try:
            directory = os.path.dirname(filepath)
            if not os.path.exists(directory):
                ensure_dir_exists(directory)
                current_app.logger.info(f"Created directory: {directory}")
        except Exception as e:
            current_app.logger.error(f"Error creating directory: {str(e)}")
            raise

    @classmethod
    def _write_chunk_safely(cls, file_path: str, chunk_data: bytes, chunk_number: int, chunk_size: int = None) -> bool:
        """Write chunk data to file with proper error handling and initial file creation."""
        max_retries = 3
        retry_delay = 1
        temp_path = f"{file_path}.tmp{chunk_number}"
        
        try:
            # Ensure directory exists
            cls._ensure_upload_dir(file_path)
            
            # For first chunk, create the file if it doesn't exist
            if chunk_number == 0 and not os.path.exists(file_path):
                open(file_path, 'wb').close()
                current_app.logger.info(f"Created initial file: {file_path}")

            for attempt in range(max_retries):
                try:
                    # Write chunk to temporary file
                    with open(temp_path, 'wb') as temp_file:
                        temp_file.write(chunk_data)
                        temp_file.flush()
                        os.fsync(temp_file.fileno())

                    # Write to main file
                    with open(file_path, 'r+b') as main_file:
                        # Set position for this chunk
                        if chunk_size is not None:
                            position = chunk_number * chunk_size
                            main_file.seek(position)
                        else:
                            main_file.seek(0, 2)  # Seek to end for append

                        # Read from temp and write to main
                        with open(temp_path, 'rb') as temp_file:
                            main_file.write(temp_file.read())
                        
                        main_file.flush()
                        os.fsync(main_file.fileno())

                    # Success - remove temp file and return
                    if os.path.exists(temp_path):
                        os.remove(temp_path)
                    return True

                except (IOError, OSError) as e:
                    current_app.logger.warning(f"Write attempt {attempt + 1} failed: {str(e)}")
                    if attempt < max_retries - 1:
                        time.sleep(retry_delay)
                        retry_delay *= 2
                    else:
                        current_app.logger.error(f"Failed to write chunk after {max_retries} attempts")
                        raise

            return False

        except Exception as e:
            current_app.logger.error(f"Error writing chunk: {str(e)}")
            # Clean up temp file if it exists
            if os.path.exists(temp_path):
                try:
                    os.remove(temp_path)
                except:
                    pass
            raise

    @classmethod
    def process_chunk(cls, file, chunk: int, total_chunks: int, chunk_size: int, 
                     filename: str, base_upload_folder: str) -> Dict[str, Any]:
        """Handle file chunk processing with improved error handling."""
        if not base_upload_folder:
            raise ValueError("UPLOAD_FOLDER not set in configuration")

        upload_id = f"{filename}_{total_chunks}"
        
        with cls._processing_lock:
            try:
                # Initialize new upload
                if chunk == 0:
                    current_app.logger.info(f"Initializing new upload for {filename}")
                    if upload_id in cls._active_uploads:
                        current_app.logger.warning(f"Clearing existing upload state for {filename}")
                        cls._release_resources(upload_id)
                    
                    metadata = json.loads(request.form['metadata'])
                    folder_name = metadata.get('folder_name', '')
                    upload_folder = UploadHandler.create_upload_folder(base_upload_folder, folder_name)
                    metadata['upload_folder'] = upload_folder
                    
                    cls._active_uploads[upload_id] = {
                        'chunks_received': set(),
                        'metadata': metadata,
                        'upload_folder': upload_folder,
                        'last_chunk_time': time.time()
                    }
                    
                    MetadataHandler.save_metadata(metadata, upload_folder, filename)
                else:
                    # Verify upload exists and hasn't timed out
                    if upload_id not in cls._active_uploads:
                        raise ValueError("Upload not properly initialized")
                    
                    if time.time() - cls._active_uploads[upload_id]['last_chunk_time'] > 300:
                        cls._release_resources(upload_id)
                        raise ValueError("Upload timeout - session expired")
                    
                    metadata = cls._active_uploads[upload_id]['metadata']
                    upload_folder = cls._active_uploads[upload_id]['upload_folder']

                # Check for duplicate chunks
                if chunk in cls._active_uploads[upload_id]['chunks_received']:
                    current_app.logger.warning(f"Duplicate chunk received: {chunk}/{total_chunks}")
                    return {'status': 'Chunk already processed'}

                filepath = os.path.join(upload_folder, filename)
                chunk_lock = cls._get_chunk_lock(filepath)

                with chunk_lock:
                    current_app.logger.info(f"Processing chunk {chunk+1}/{total_chunks} for file {filename}")
                    
                    # Read chunk data
                    chunk_data = file.read()
                    
                    # Write chunk safely
                    if not cls._write_chunk_safely(filepath, chunk_data, chunk, chunk_size):
                        raise IOError(f"Failed to write chunk {chunk+1}/{total_chunks}")

                    # Update upload state
                    cls._active_uploads[upload_id]['chunks_received'].add(chunk)
                    cls._active_uploads[upload_id]['last_chunk_time'] = time.time()

                # Process final chunk
                if chunk == total_chunks - 1 and len(cls._active_uploads[upload_id]['chunks_received']) == total_chunks:
                    try:
                        result = FileProcessor.process_completed_upload(
                            filepath, upload_folder, filename, metadata
                        )
                        cls._release_resources(upload_id, filepath)
                        return result
                    except Exception as e:
                        current_app.logger.error(f"Error in final processing: {str(e)}")
                        cls._release_resources(upload_id, filepath)
                        raise

                return {'status': 'Chunk received'}

            except Exception as e:
                current_app.logger.error(f"Error processing chunk: {str(e)}")
                cls._release_resources(upload_id)
                raise


project\client_app\operations\metadata_handler.py
=================================================
# project/client_app/operations/metadata_handler.py

from flask import current_app
import os
import json
from datetime import datetime
from ..utils import get_metadata_path, find_metadata_file

class MetadataHandler:
    @staticmethod
    def save_metadata(metadata: dict, upload_folder: str, filename: str) -> dict:
        """Save metadata to file with enhanced error handling and proper file handling"""
        try:
            # Remove any _complete suffix from filename when creating metadata path
            base_filename = filename.replace('_complete', '')
            metadata_path = get_metadata_path(upload_folder, base_filename)
            current_app.logger.info(f"Saving metadata to: {metadata_path}")
            
            # Add timestamp using datetime
            metadata['last_updated'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(metadata_path), exist_ok=True)
            
            # Update existing metadata if it exists
            if os.path.exists(metadata_path):
                try:
                    with open(metadata_path, 'r') as f:
                        existing_metadata = json.load(f)
                    # Merge existing metadata with new metadata
                    existing_metadata.update(metadata)
                    metadata = existing_metadata
                except Exception as e:
                    current_app.logger.error(f"Error reading existing metadata: {str(e)}")

            # Write the metadata
            with open(metadata_path, 'w') as f:
                json.dump(metadata, f, indent=4)
            
            # If this is a completion update, ensure we're not creating a duplicate file
            if '_complete' in filename and not metadata_path.endswith('_complete.json'):
                complete_metadata_path = get_metadata_path(upload_folder, filename)
                if os.path.exists(complete_metadata_path) and complete_metadata_path != metadata_path:
                    try:
                        os.remove(complete_metadata_path)
                        current_app.logger.info(f"Removed duplicate metadata file: {complete_metadata_path}")
                    except Exception as e:
                        current_app.logger.error(f"Error removing duplicate metadata: {str(e)}")
            
            return metadata
            
        except Exception as e:
            current_app.logger.error(f"Error saving metadata: {str(e)}")
            raise

    @staticmethod
    def load_metadata(base_upload_folder: str, filename: str) -> dict:
        """Load metadata from file with improved file searching"""
        try:
            # First try to find the metadata file without _complete suffix
            base_filename = filename.replace('_complete', '')
            metadata_path = find_metadata_file(base_upload_folder, base_filename)
            
            # If not found, try with _complete suffix
            if not metadata_path and not filename.endswith('_complete'):
                metadata_path = find_metadata_file(base_upload_folder, f"{base_filename}_complete")
            
            if not metadata_path:
                raise ValueError(f"Metadata file not found for {filename}")
                
            current_app.logger.info(f"Found metadata file: {metadata_path}")
            with open(metadata_path, 'r') as f:
                metadata = json.load(f)
                
            # Ensure critical fields exist
            metadata.setdefault('originalFilename', 'Unknown File')
            metadata.setdefault('newFilename', 'N/A')
            metadata.setdefault('operation', 'Unknown Operation')
            metadata.setdefault('dateOfCollection', 'N/A')
            metadata.setdefault('itemNumber', 'N/A')
            metadata.setdefault('subNumber', 'N/A')
            
            return metadata
            
        except Exception as e:
            current_app.logger.error(f"Error loading metadata: {str(e)}")
            raise


project\client_app\operations\upload_handler.py
===============================================
# project/client_app/operations/upload_handler.py

from flask import current_app
import os
import time
from ..utils import ensure_dir_exists

class UploadHandler:
    @staticmethod
    def handle_chunk(file, chunk, total_chunks, chunk_size, filename, upload_folder):
        """Write a chunk to the file with enhanced network share handling"""
        filepath = os.path.join(upload_folder, filename)
        max_retries = 3
        retry_delay = 1  # Start with 1 second delay
        
        for attempt in range(max_retries):
            try:
                # If this is the first chunk, ensure directory exists
                if chunk == 0:
                    ensure_dir_exists(upload_folder)

                # Simplified file writing without Windows-specific locking
                with open(filepath, 'ab') as f:
                    if chunk_size > 0:
                        f.seek(chunk * chunk_size)
                    file_chunk = file.read()
                    f.write(file_chunk)
                    f.flush()
                    os.fsync(f.fileno())  # Force write to disk

                current_app.logger.info(f"Chunk {chunk + 1}/{total_chunks} written successfully")
                return

            except IOError as e:
                current_app.logger.warning(f"Attempt {attempt + 1} failed: {str(e)}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    retry_delay *= 2  # Exponential backoff
                else:
                    current_app.logger.error(f"Failed to write chunk after {max_retries} attempts")
                    raise

            except Exception as e:
                current_app.logger.error(f"Error writing chunk: {str(e)}")
                raise

    @staticmethod
    def create_upload_folder(base_upload_folder, folder_name):
        """Create upload folder and return path"""
        upload_folder = os.path.join(base_upload_folder, folder_name)
        ensure_dir_exists(upload_folder)
        return upload_folder


project\client_app\operations\__init__.py
=========================================
# project/client_app/operations/__init__.py
"""Operations package initialization."""

from .file_operations import FileOperations
from .cleanup_operations import CleanupOperations
from .upload_handler import UploadHandler
from .metadata_handler import MetadataHandler
from .processing import FileProcessor  # Updated import path

__all__ = [
    'FileOperations',
    'CleanupOperations', 
    'UploadHandler',
    'MetadataHandler',
    'FileProcessor'
]


project\client_app\operations\processing\cleanup_handler.py
===========================================================
# project/client_app/operations/processing/cleanup_handler.py
"""Cleanup operations for failed uploads."""

import os
from flask import current_app

class CleanupHandler:
    @classmethod
    def cleanup_failed_upload(cls, upload_folder: str, filename: str) -> None:
        """Clean up files from a failed upload."""
        try:
            filepath = os.path.join(upload_folder, filename)
            metadata_path = os.path.join(upload_folder, f"{filename}_metadata.json")
            
            # Remove the main file if it exists
            if os.path.exists(filepath):
                os.remove(filepath)
                current_app.logger.info(f"Removed failed upload file: {filepath}")
            
            # Remove the metadata file if it exists
            if os.path.exists(metadata_path):
                os.remove(metadata_path)
                current_app.logger.info(f"Removed failed upload metadata: {metadata_path}")
            
            # Remove the folder if it's empty
            if os.path.exists(upload_folder) and not os.listdir(upload_folder):
                os.rmdir(upload_folder)
                current_app.logger.info(f"Removed empty upload folder: {upload_folder}")
                
        except Exception as e:
            current_app.logger.error(f"Error cleaning up failed upload: {str(e)}")
            raise



project\client_app\operations\processing\completion_handler.py
==============================================================
# project/client_app/operations/processing/completion_handler.py
"""Final processing steps and completion handling."""

import os
import time
from flask import current_app
from ..metadata_handler import MetadataHandler

class CompletionHandler:
    @classmethod
    def handle_completion(cls, filepath: str, filename: str, metadata: dict, 
                         upload_folder: str, original_hash: str) -> dict:
        """Handle final processing steps and completion."""
        try:
            # Update metadata with final information
            metadata.update({
                'final_filename': filename,
                'filePath': filepath,
                'originalFilename': os.path.basename(filepath),
                'newFilename': filename,
                'fileSize': os.path.getsize(filepath),
                'fileHash': original_hash,  # Use already verified hash
                'verified': True,  # We know it's verified from previous check
                'processingCompleted': True,
                'completedAt': time.strftime('%Y-%m-%d %H:%M:%S')
            })
            
            MetadataHandler.save_metadata(metadata, upload_folder, filename)
            
            return {
                'status': 'success',
                'filePath': filepath,
                'originalFilename': os.path.basename(filepath),
                'newFilename': filename,
                'originalHash': original_hash,
                'newHash': original_hash,  # Use same hash since file content hasn't changed
                'verified': True,
                'fileSize': metadata['fileSize'],
                'success': True,
                'metadata': metadata
            }
            
        except Exception as e:
            current_app.logger.error(f"Error in completion handling: {str(e)}")
            raise


project\client_app\operations\processing\core_processor.py
==========================================================
# project/client_app/operations/processing/core_processor.py
"""Core file processing functionality."""

from flask import current_app
import os
import time
from threading import Lock
from ..metadata_handler import MetadataHandler
from ...file_utils import calculate_file_hash

class CoreProcessor:
    _processing_lock = Lock()

    @classmethod
    def validate_processing_requirements(cls, filepath: str, metadata: dict) -> None:
        """Validate all requirements for file processing."""
        if not os.path.exists(filepath):
            raise ValueError(f"File not found: {filepath}")
            
        if not metadata:
            raise ValueError("Metadata is required for processing")
            
        if not metadata.get('originalFileHash'):
            raise ValueError("Original file hash is required in metadata")
            
        if not os.path.exists(os.path.dirname(filepath)):
            raise ValueError(f"Upload folder not found: {os.path.dirname(filepath)}")

    @classmethod
    def calculate_file_hash(cls, filepath: str) -> str:
        """Calculate hash of the given file."""
        try:
            current_app.logger.info(f"Calculating hash for file: {filepath}")
            file_hash = calculate_file_hash(filepath)
            current_app.logger.info(f"Hash calculation complete: {file_hash}")
            return file_hash
        except Exception as e:
            current_app.logger.error(f"Error calculating file hash: {str(e)}")
            raise

    @classmethod
    def verify_file_integrity(cls, filepath: str, original_hash: str) -> bool:
        """Verify the integrity of a file by comparing its hash."""
        try:
            current_app.logger.info(f"Verifying file integrity: {filepath}")
            calculated_hash = cls.calculate_file_hash(filepath)
            is_valid = calculated_hash == original_hash
            current_app.logger.info(f"File integrity verification result: {is_valid}")
            return is_valid
        except Exception as e:
            current_app.logger.error(f"Error verifying file integrity: {str(e)}")
            return False

    @classmethod
    def update_metadata_with_error(cls, metadata: dict, error_message: str, 
                                 upload_folder: str, filename: str) -> None:
        """Update metadata file with error information."""
        try:
            metadata.update({
                'processingError': error_message,
                'processingCompleted': False,
                'errorTimestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'fileVerified': False
            })
            MetadataHandler.save_metadata(metadata, upload_folder, filename)
        except Exception as e:
            current_app.logger.error(f"Failed to update metadata with error: {str(e)}")

    @classmethod
    def process_completed_file(cls, filepath: str, original_hash: str, 
                             metadata: dict, upload_folder: str) -> dict:
        """Process a completed file upload."""
        try:
            # Calculate final hash
            final_hash = cls.calculate_file_hash(filepath)
            
            # Verify integrity
            is_verified = final_hash == original_hash
            
            # Update metadata
            metadata.update({
                'finalFileHash': final_hash,
                'fileVerified': is_verified,
                'processingCompleted': True,
                'completedAt': time.strftime('%Y-%m-%d %H:%M:%S'),
                'fileSize': os.path.getsize(filepath)
            })
            
            MetadataHandler.save_metadata(metadata, upload_folder, os.path.basename(filepath))
            
            return {
                'success': True,
                'verified': is_verified,
                'originalHash': original_hash,
                'finalHash': final_hash,
                'filePath': filepath,
                'metadata': metadata
            }
            
        except Exception as e:
            error_msg = f"Error processing completed file: {str(e)}"
            current_app.logger.error(error_msg)
            cls.update_metadata_with_error(metadata, error_msg, upload_folder, os.path.basename(filepath))
            raise


project\client_app\operations\processing\file_processor.py
==========================================================
# project/client_app/operations/processing/file_processor.py

import os
import time
import shutil
from typing import Dict, Any, Optional, Tuple
from flask import current_app
from ..metadata_handler import MetadataHandler
from ...file_utils import calculate_file_hash
from .core_processor import CoreProcessor
from .file_rename import FileRenameHandler
from .cleanup_handler import CleanupHandler
from .completion_handler import CompletionHandler

class FileProcessor:
    @staticmethod
    def ensure_dir_exists(directory: str) -> None:
        """Ensure directory exists, create if it doesn't."""
        if not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)

    @staticmethod
    def safe_rename(src: str, dst: str, max_retries: int = 3) -> bool:
        """
        Safely rename a file with retries.
        Returns True if successful, False otherwise.
        """
        for attempt in range(max_retries):
            try:
                if os.path.exists(dst):
                    current_app.logger.warning(f"Destination already exists: {dst}")
                    return False
                    
                os.rename(src, dst)
                current_app.logger.info(f"Successfully renamed: {src} -> {dst}")
                return True
                
            except OSError as e:
                current_app.logger.warning(f"Rename attempt {attempt + 1} failed: {str(e)}")
                if attempt < max_retries - 1:
                    time.sleep(2)  # Wait before retry
                
        return False

    @classmethod
    def validate_upload(cls, filepath: str, metadata: dict) -> Tuple[bool, str]:
        """
        Validate upload requirements.
        Returns (is_valid, error_message)
        """
        if not os.path.exists(filepath):
            return False, f"File not found: {filepath}"
            
        if not metadata:
            return False, "Metadata is required"
            
        if not metadata.get('originalFileHash'):
            return False, "Original file hash is required"
            
        return True, ""

    @classmethod
    def process_completed_upload(cls, filepath: str, upload_folder: str, 
                               filename: str, metadata: dict) -> Dict[str, Any]:
        """
        Process completed file upload following exact sequence requirements.
        Handles all stages from initial verification through completion.
        """
        try:
            # Initial validation
            is_valid, error_msg = cls.validate_upload(filepath, metadata)
            if not is_valid:
                raise ValueError(error_msg)

            # 1. Create/update initial metadata
            metadata.update({
                'processingStarted': time.strftime('%Y-%m-%d %H:%M:%S'),
                'originalFilename': filename,
                'uploadFolder': upload_folder
            })
            MetadataHandler.save_metadata(metadata, upload_folder, filename)
            current_app.logger.info("Initial metadata created")

            # 2. Calculate original hash and verify
            current_app.logger.info(f"Calculating hash for file: {filepath}")
            original_hash = metadata['originalFileHash']  # From chunked upload
            file_size = os.path.getsize(filepath)

            # 3. Update metadata with file details
            metadata.update({
                'fileSize': file_size,
                'originalFileHash': original_hash,
                'timestampVerified': time.strftime('%Y-%m-%d %H:%M:%S')
            })
            MetadataHandler.save_metadata(metadata, upload_folder, filename)
            current_app.logger.info("Metadata updated with file details")

            # 4. Verify file integrity
            current_app.logger.info("Verifying file integrity")
            new_hash = calculate_file_hash(filepath)
            is_verified = new_hash == original_hash

            # 5. Update metadata with verification results
            metadata.update({
                'newFileHash': new_hash,
                'verified': is_verified,
                'integrityVerified': time.strftime('%Y-%m-%d %H:%M:%S')
            })
            MetadataHandler.save_metadata(metadata, upload_folder, filename)
            current_app.logger.info(f"File verification completed: {is_verified}")

            if not is_verified:
                raise ValueError("File integrity verification failed - hashes do not match")

            # 6. Handle file rename if requested
            if metadata.get('rename_file'):
                new_filename = metadata.get('new_filename')
                if new_filename:
                    current_app.logger.info(f"Renaming file to: {new_filename}")
                    new_filepath = os.path.join(upload_folder, new_filename)
                    
                    # Rename both file and metadata
                    if cls.safe_rename(filepath, new_filepath):
                        old_meta = os.path.join(upload_folder, f"{filename}_metadata.json")
                        new_meta = os.path.join(upload_folder, f"{new_filename}_metadata.json")
                        cls.safe_rename(old_meta, new_meta)
                        
                        filepath = new_filepath
                        filename = new_filename
                        metadata.update({
                            'newFilename': new_filename,
                            'currentFilename': new_filename
                        })
                        MetadataHandler.save_metadata(metadata, upload_folder, filename)
                        current_app.logger.info("File rename completed")
                    else:
                        raise OSError(f"Failed to rename file to {new_filename}")

            # 7. Add _complete suffix
            base_name, ext = os.path.splitext(filename)
            if not base_name.endswith('_complete'):
                complete_filename = f"{base_name}_complete{ext}"
                complete_filepath = os.path.join(upload_folder, complete_filename)
                
                current_app.logger.info(f"Adding completion suffix: {complete_filename}")
                
                if cls.safe_rename(filepath, complete_filepath):
                    # Rename metadata file
                    old_meta = os.path.join(upload_folder, f"{filename}_metadata.json")
                    new_meta = os.path.join(upload_folder, f"{complete_filename}_metadata.json")
                    cls.safe_rename(old_meta, new_meta)
                    
                    filepath = complete_filepath
                    filename = complete_filename
                    metadata.update({
                        'final_filename': complete_filename,
                        'currentFilename': complete_filename
                    })
                    MetadataHandler.save_metadata(metadata, upload_folder, filename)
                    current_app.logger.info("Completion suffix added")
                else:
                    raise OSError(f"Failed to add completion suffix")

            # 8. Final metadata update
            metadata.update({
                'processingCompleted': True,
                'completedAt': time.strftime('%Y-%m-%d %H:%M:%S')
            })
            MetadataHandler.save_metadata(metadata, upload_folder, filename)

            # 9. Return final status
            return {
                'status': 'success',
                'filePath': filepath,
                'originalFilename': metadata['originalFilename'],
                'newFilename': filename,
                'originalHash': original_hash,
                'newHash': new_hash,
                'fileSize': file_size,
                'verified': is_verified,
                'success': True,
                'metadata': metadata
            }

        except Exception as e:
            current_app.logger.error(f"Error in file processing: {str(e)}")
            
            try:
                # Update metadata with error
                metadata.update({
                    'processingError': str(e),
                    'processingCompleted': False,
                    'errorTimestamp': time.strftime('%Y-%m-%d %H:%M:%S')
                })
                MetadataHandler.save_metadata(metadata, upload_folder, filename)
                
                # Clean up failed upload
                CleanupHandler.cleanup_failed_upload(upload_folder, filename)
                
            except Exception as cleanup_error:
                current_app.logger.error(f"Error during cleanup: {str(cleanup_error)}")
            
            return {
                'status': 'File processing failed',
                'error': str(e),
                'filePath': filepath,
                'success': False
            }


project\client_app\operations\processing\file_rename.py
=======================================================
# project/client_app/operations/processing/file_rename.py

import os
import time
from flask import current_app

class FileRenameHandler:
    @classmethod
    def handle_rename_operation(cls, current_path: str, new_path: str, 
                              metadata_path: str = None, new_metadata_path: str = None) -> bool:
        """Handle file rename operation with retries and proper file handling."""
        
        if not os.path.exists(current_path):
            current_app.logger.error(f"Source file not found: {current_path}")
            return False
            
        if os.path.exists(new_path):
            current_app.logger.error(f"Destination file already exists: {new_path}")
            return False
            
        try:
            # Ensure the destination directory exists
            os.makedirs(os.path.dirname(new_path), exist_ok=True)
            
            # First try to rename the file
            os.rename(current_path, new_path)
            current_app.logger.info(f"Successfully renamed file to: {new_path}")
            
            # If metadata paths are provided, rename the metadata file too
            if metadata_path and new_metadata_path and os.path.exists(metadata_path):
                try:
                    os.rename(metadata_path, new_metadata_path)
                    current_app.logger.info(f"Successfully renamed metadata to: {new_metadata_path}")
                except Exception as e:
                    current_app.logger.error(f"Error renaming metadata file: {str(e)}")
                    # Try to revert the file rename if metadata rename fails
                    try:
                        os.rename(new_path, current_path)
                    except:
                        pass
                    return False
                    
            return True
                
        except Exception as e:
            current_app.logger.error(f"Error in rename operation: {str(e)}")
            return False


project\client_app\operations\processing\status_tracker.py
==========================================================
# project/client_app/operations/processing/status_tracker.py
"""File processing status tracking."""

from flask import current_app
from ..metadata_handler import MetadataHandler

class ProcessingStatusTracker:
    @classmethod
    def get_processing_status(cls, upload_folder: str, filename: str) -> dict:
        """Get current processing status from metadata."""
        try:
            metadata = MetadataHandler.load_metadata(upload_folder, filename)
            return {
                'completed': metadata.get('processingCompleted', False),
                'error': metadata.get('processingError'),
                'verified': metadata.get('verified', False),
                'originalHash': metadata.get('originalFileHash'),
                'newHash': metadata.get('fileHash'),
                'finalFilename': metadata.get('final_filename'),
                'status': 'error' if metadata.get('processingError') else 
                         'completed' if metadata.get('processingCompleted') else 
                         'processing'
            }
        except Exception as e:
            current_app.logger.error(f"Error getting processing status: {str(e)}")
            return {
                'status': 'error',
                'error': str(e)
            }


project\client_app\operations\processing\__init__.py
====================================================
# project/client_app/operations/processing/__init__.py
"""Processing package initialization."""

from .core_processor import CoreProcessor
from .file_rename import FileRenameHandler
from .status_tracker import ProcessingStatusTracker
from .cleanup_handler import CleanupHandler
from .completion_handler import CompletionHandler
from .file_processor import FileProcessor  # Add FileProcessor to exports

__all__ = [
    'CoreProcessor',
    'FileRenameHandler',
    'ProcessingStatusTracker',
    'CleanupHandler',
    'CompletionHandler',
    'FileProcessor'  # Export FileProcessor
]


project\client_app\routes\cleanup_routes.py
===========================================
from flask import Blueprint, request, jsonify, current_app
import traceback
from ..operations.cleanup_operations import CleanupOperations

cleanup_routes = Blueprint('cleanup_routes', __name__)

@cleanup_routes.route('/cancel-upload', methods=['POST'])
def cancel_upload():
    """Handle upload cancellation request."""
    try:
        data = request.json
        if not data or 'folder_name' not in data:
            return jsonify({'error': 'No folder name provided'}), 400

        base_upload_folder = current_app.config.get('UPLOAD_FOLDER')
        response, status_code = CleanupOperations.cancel_upload(
            data['folder_name'], base_upload_folder
        )
        
        return jsonify(response), status_code

    except Exception as e:
        current_app.logger.error(f"Error in cancel_upload: {str(e)}")
        current_app.logger.error(traceback.format_exc())
        return jsonify({'error': str(e), 'traceback': traceback.format_exc()}), 500


project\client_app\routes\history_routes.py
===========================================
# project/client_app/routes/history_routes.py
import os
import shutil
from flask import Blueprint, jsonify, request, current_app, render_template
import json
import csv
from datetime import datetime

history_routes = Blueprint('history_routes', __name__)

def get_metadata_from_folder(folder_path):
    """Extract metadata from a folder's metadata.json file."""
    try:
        # Look for both regular and _complete metadata files
        metadata_files = [f for f in os.listdir(folder_path) 
                         if f.endswith('_metadata.json')]
        
        if not metadata_files:
            return None
            
        # Prefer the completed metadata file if it exists
        completed_metadata = next((f for f in metadata_files if '_complete_metadata.json' in f), None)
        metadata_path = os.path.join(folder_path, 
                                   completed_metadata if completed_metadata else metadata_files[0])
        
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)
            
        # Ensure required fields exist
        metadata.setdefault('originalFilename', 'Unknown File')
        metadata.setdefault('newFilename', 'N/A')
        metadata.setdefault('operation', 'Unknown Operation')
        metadata.setdefault('dateOfCollection', 'N/A')
        metadata.setdefault('itemNumber', 'N/A')
        metadata.setdefault('subNumber', 'N/A')
        metadata.setdefault('fileSize', 0)
        
        return metadata
        
    except Exception as e:
        current_app.logger.error(f"Error reading metadata: {str(e)}")
        return None

def get_inventory_from_folder(folder_path):
    """Extract chunk inventory from any *_inventory.csv files in the folder."""
    try:
        # Look for any file ending with _inventory.csv
        inventory_files = [f for f in os.listdir(folder_path) if f.endswith('_inventory.csv')]
        
        if not inventory_files:
            current_app.logger.debug(f"No inventory files found in {folder_path}")
            return []

        # Use the first inventory file found
        inventory_path = os.path.join(folder_path, inventory_files[0])
        current_app.logger.info(f"Found inventory file: {inventory_path}")

        chunks = []
        try:
            with open(inventory_path, 'r') as f:
                # Skip empty lines and handle potential BOM
                csv_content = f.read().strip()
                if csv_content.startswith('\ufeff'):
                    csv_content = csv_content[1:]
                
                if not csv_content:
                    return []

                # Create a CSV reader from the content
                reader = csv.DictReader(csv_content.splitlines())
                
                # Map CSV columns to expected names
                for row in reader:
                    chunk_data = {
                        'file': row.get('filename', row.get('file', '')),
                        'chunk': row.get('chunk', ''),
                        'hash': row.get('hash', ''),
                        'size': row.get('size', '0')
                    }
                    chunks.append(chunk_data)
                
                current_app.logger.info(f"Successfully read {len(chunks)} chunks from inventory")
                return chunks
        except Exception as e:
            current_app.logger.error(f"Error reading CSV file {inventory_path}: {str(e)}")
            return []

    except Exception as e:
        current_app.logger.error(f"Error accessing folder {folder_path}: {str(e)}")
        return []

@history_routes.route('/history')
def history():
    """Render the history page."""
    return render_template('history.html')
@history_routes.route('/api/folders')
def get_folders():
    """Get all folders with their metadata and inventory."""
    try:
        upload_folder = current_app.config['UPLOAD_FOLDER']
        folders_data = []

        # Get folders and sort by modification time (newest first)
        folders = [(f.path, f.name) for f in os.scandir(upload_folder) if f.is_dir()]
        folders.sort(key=lambda x: os.path.getmtime(x[0]), reverse=True)

        for folder_path, folder_name in folders:
            metadata = get_metadata_from_folder(folder_path)
            if metadata:
                # Get inventory and log its presence
                inventory = get_inventory_from_folder(folder_path)
                has_inventory = bool(inventory)
                
                # Format file size for display
                file_size_gb = metadata.get('fileSize', 0) / (1024 * 1024 * 1024)
                
                folder_info = {
                    'name': folder_name,
                    'metadata': {
                        **metadata,
                        'formatted_file_size': f"{file_size_gb:.2f} GB",
                        'formatted_item_sub': f"Item NO: {metadata.get('itemNumber', 'N/A')} " +
                                            f"Sub {metadata.get('subNumber', 'N/A')}"
                    },
                    'inventory': inventory,
                    'has_inventory': has_inventory
                }
                folders_data.append(folder_info)

        return jsonify(folders_data)

    except Exception as e:
        current_app.logger.error(f"Error getting folders: {str(e)}")
        return jsonify({'error': str(e)}), 500

@history_routes.route('/api/delete-folder', methods=['POST'])
def delete_folder():
    """Handle folder deletion requests"""
    try:
        data = request.json
        if not data or 'folder_path' not in data:
            return jsonify({'error': 'No folder path provided'}), 400

        folder_path = data['folder_path']
        
        # Verify the folder path is within the allowed upload directory
        upload_folder = current_app.config['UPLOAD_FOLDER']
        if not os.path.commonpath([folder_path, upload_folder]) == upload_folder:
            return jsonify({'error': 'Invalid folder path'}), 400

        if not os.path.exists(folder_path):
            return jsonify({'error': 'Folder not found'}), 404

        # Remove the directory and all its contents
        shutil.rmtree(folder_path)
        
        current_app.logger.info(f"Successfully deleted folder: {folder_path}")
        return jsonify({
            'status': 'success',
            'message': 'Folder deleted successfully'
        }), 200

    except Exception as e:
        current_app.logger.error(f"Error deleting folder: {str(e)}")
        return jsonify({'error': str(e)}), 500
@history_routes.route('/api/resend-chunk', methods=['POST'])
def resend_chunk():
    """Handle chunk resend request."""
    try:
        data = request.json
        current_app.logger.info(f"Received resend request data: {data}")
        
        if not data or not data.get('metadata'):
            current_app.logger.error("No metadata provided in request")
            return jsonify({'error': 'Metadata required'}), 400

        metadata = data.get('metadata')
        new_filename = metadata.get('newFilename') or metadata.get('final_filename')
        chunk_number = str(data.get('chunk', '')).replace('chunk', '').strip()
        
        if not new_filename:
            current_app.logger.error("No newFilename found in metadata")
            return jsonify({'error': 'New filename not found in metadata'}), 400

        # Extract base name by removing _complete and extension
        base_name = new_filename.rsplit('_complete', 1)[0]
        current_app.logger.info(f"Base name for resend file: {base_name}")

        # Create resend filename with chunk number
        resend_filename = f"{base_name}_resend{chunk_number}.json"
        current_app.logger.info(f"Generated resend filename: {resend_filename}")

        # Get upload folder from metadata
        upload_folder = metadata.get('upload_folder')
        if not upload_folder:
            current_app.logger.error("Upload folder not found in metadata")
            return jsonify({'error': 'Upload folder not found'}), 400

        # Add resend information to metadata
        resend_metadata = metadata.copy()
        resend_metadata.update({
            'resendChunk': data.get('chunk'),
            'resendChunkHash': data.get('hash'),
            'resendChunkSize': data.get('size')
        })

        # Create resend json file
        resend_path = os.path.join(upload_folder, resend_filename)
        current_app.logger.info(f"Creating resend file at: {resend_path}")

        with open(resend_path, 'w') as f:
            json.dump(resend_metadata, f, indent=4)

        return jsonify({
            'message': 'Resend request created successfully',
            'location': resend_path,
            'filename': resend_filename
        })

    except Exception as e:
        current_app.logger.error(f"Error processing resend: {str(e)}")
        current_app.logger.error(f"Full error details: ", exc_info=True)
        return jsonify({'error': str(e)}), 500


project\client_app\routes\main_routes.py
========================================
# project/client_app/routes/main_routes.py

import os
import json
from flask import Blueprint, render_template, request, jsonify, current_app
from datetime import datetime
from ..utils import get_temp_dir
from .history_routes import get_metadata_from_folder

main_routes = Blueprint('main_routes', __name__)

@main_routes.route('/')
@main_routes.route('/home')
def home():
    """Render the home page."""
    return render_template('home.html')

@main_routes.route('/history')
def history():
    """Render the history page."""
    try:
        upload_folder = current_app.config['UPLOAD_FOLDER']
        folder_data = []
        
        # Get all folders and sort by modification time (newest first)
        folders = [(f.path, f.name) for f in os.scandir(upload_folder) if f.is_dir()]
        folders.sort(key=lambda x: os.path.getmtime(x[0]), reverse=True)

        for folder_path, folder_name in folders:
            metadata = get_metadata_from_folder(folder_path)
            if metadata:
                folder_data.append({
                    "name": metadata.get("operation", "Unknown Operation"),
                    "date": metadata.get("dateOfCollection", "Unknown Date"),
                    "folder": folder_name,
                    "verified": metadata.get("verified", False),
                    "metadata": metadata
                })

        current_app.logger.info(f"Found {len(folder_data)} folders with metadata")
        return render_template('history.html', folder_data=folder_data)
        
    except Exception as e:
        current_app.logger.error(f"Error loading history page: {str(e)}")
        return render_template('history.html', folder_data=[])

@main_routes.route('/config')
def get_config():
    """Get application configuration."""
    config = {
        'UPLOAD_FOLDER': current_app.config.get('UPLOAD_FOLDER', '/tmp/uploads'),
        'MAX_FILE_SIZE': current_app.config.get('MAX_FILE_SIZE', 200 * 1024 * 1024 * 1024),
        'SYSTEM_NAME': current_app.config.get('SYSTEM_NAME', 'Unknown')
    }
    return jsonify(config)


project\client_app\routes\__init__.py
=====================================
# project/client_app/routes/__init__.py
"""Routes package initialization."""

from flask import Blueprint
from .main_routes import main_routes
from .cleanup_routes import cleanup_routes
from .history_routes import history_routes
from .upload import create_upload_blueprint

# Get the upload blueprint
upload_routes = create_upload_blueprint()

__all__ = [
    'main_routes',
    'upload_routes',
    'cleanup_routes',
    'history_routes'
]


project\client_app\routes\upload\hash_controller.py
===================================================
# project/client_app/routes/upload/hash_controller.py
"""Controller for handling file hash calculation routes."""

from flask import Blueprint, request, jsonify, current_app
import os
import time
import traceback
from werkzeug.utils import secure_filename
from ...file_utils import calculate_file_hash
from ...utils import get_temp_dir

hash_routes = Blueprint('hash_routes', __name__)

@hash_routes.route('/calculate-hash', methods=['POST'])
def calculate_initial_hash():
    """Calculate hash of uploaded file with enhanced error handling"""
    temp_path = None
    try:
        current_app.logger.info("Starting hash calculation")
        file = request.files.get('file')
        if not file:
            return jsonify({
                'error': 'No file received',
                'success': False,
                'details': 'File must be included in the request'
            }), 400

        temp_dir = get_temp_dir()
        temp_path = os.path.join(temp_dir, secure_filename(file.filename))
        
        # Ensure the temp directory exists
        os.makedirs(os.path.dirname(temp_path), exist_ok=True)
        
        current_app.logger.info(f"Saving file to temp location: {temp_path}")
        file.save(temp_path)
        
        current_app.logger.info("Calculating file hash...")
        file_hash = calculate_file_hash(temp_path)
        current_app.logger.info(f"Hash calculated: {file_hash}")
        
        # File cleanup with retries
        cleanup_success = False
        for attempt in range(3):
            try:
                if os.path.exists(temp_path):
                    os.close(os.open(temp_path, os.O_RDONLY))  # Close any open handles
                    os.remove(temp_path)
                    current_app.logger.info("Temporary file removed")
                    cleanup_success = True
                    break
            except Exception as e:
                current_app.logger.warning(f"Cleanup attempt {attempt + 1} failed: {str(e)}")
                time.sleep(1)
        
        if not cleanup_success:
            current_app.logger.warning("Could not remove temporary file, will be cleaned up later")
        
        return jsonify({
            'hash': file_hash,
            'success': True,
            'message': 'Hash calculated successfully'
        })

    except Exception as e:
        error_msg = str(e)
        current_app.logger.error(f"Hash calculation error: {error_msg}")
        current_app.logger.error(traceback.format_exc())
        
        # Attempt cleanup even in case of error
        if temp_path and os.path.exists(temp_path):
            try:
                os.remove(temp_path)
                current_app.logger.info("Temporary file removed after error")
            except Exception as cleanup_error:
                current_app.logger.error(f"Failed to clean up after error: {str(cleanup_error)}")
        
        return jsonify({
            'error': error_msg,
            'success': False,
            'details': traceback.format_exc(),
            'message': 'Hash calculation failed'
        }), 500


project\client_app\routes\upload\upload_controller.py
=====================================================
# project/client_app/routes/upload/upload_controller.py
"""Main controller for handling upload-related routes."""

from flask import Blueprint, jsonify, current_app, request  # Added request import
import traceback
from werkzeug.utils import secure_filename
from ...operations.file_operations import FileOperations

upload_routes = Blueprint('upload_routes', __name__)

@upload_routes.route('/upload-chunk', methods=['POST'])
def upload_chunk():
    """Handle chunk upload requests"""
    try:
        # Log the start of upload processing
        current_app.logger.info("Processing new chunk upload request")
        
        # Validate file presence
        file = request.files.get('file')
        if not file:
            current_app.logger.error("No file chunk received")
            return jsonify({'error': 'No file chunk received'}), 400

        # Get chunk information
        try:
            chunk = int(request.form.get('chunk', 0))
            total_chunks = int(request.form.get('totalChunks', 1))
            chunk_size = int(request.form.get('chunkSize', 0))
        except (TypeError, ValueError) as e:
            current_app.logger.error(f"Invalid chunk information: {str(e)}")
            return jsonify({'error': 'Invalid chunk information provided'}), 400

        # Secure the filename
        filename = secure_filename(file.filename)
        if not filename:
            current_app.logger.error("Invalid filename provided")
            return jsonify({'error': 'Invalid filename'}), 400

        # Get the base upload folder from config
        base_upload_folder = current_app.config.get('UPLOAD_FOLDER')
        if not base_upload_folder:
            current_app.logger.error("Upload folder not configured")
            return jsonify({'error': 'Upload folder not configured'}), 500

        # Log chunk processing details
        current_app.logger.info(f"Processing chunk {chunk + 1}/{total_chunks} for file: {filename}")

        # Process the chunk
        try:
            result = FileOperations.process_chunk(
                file=file,
                chunk=chunk,
                total_chunks=total_chunks,
                chunk_size=chunk_size,
                filename=filename,
                base_upload_folder=base_upload_folder
            )
            current_app.logger.info(f"Chunk processed successfully: {result}")
            return result

        except Exception as e:
            current_app.logger.error(f"Error in chunk processing: {str(e)}")
            current_app.logger.error(traceback.format_exc())
            return jsonify({
                'error': str(e),
                'traceback': traceback.format_exc()
            }), 500

    except Exception as e:
        current_app.logger.error(f"Error processing chunk: {str(e)}")
        current_app.logger.error(traceback.format_exc())
        return jsonify({
            'error': str(e),
            'traceback': traceback.format_exc()
        }), 500


project\client_app\routes\upload\verification_controller.py
===========================================================
# project/client_app/routes/upload/verification_controller.py
"""Controller for handling file verification routes."""

from flask import Blueprint, request, jsonify, current_app
import os
import json
import traceback

verification_routes = Blueprint('verification_routes', __name__)

@verification_routes.route('/verify-file', methods=['POST'])
def verify_file():
    """Verify uploaded file integrity."""
    try:
        data = request.json
        if not data:
            current_app.logger.error("No data received in verify_file")
            return jsonify({
                'verified': False,
                'error': 'No data received',
                'finalFilename': 'Unknown',
                'newHash': 'Verification Failed'
            }), 200

        # Get file path from the data
        file_path = data.get('filePath')
        if not file_path:
            current_app.logger.error("No file path provided in verify_file")
            return jsonify({
                'verified': False,
                'error': 'Missing file path',
                'finalFilename': 'Unknown',
                'newHash': 'Verification Failed'
            }), 200

        # Ensure the directory path exists
        dir_path = os.path.dirname(file_path)
        if not os.path.exists(dir_path):
            current_app.logger.error(f"Directory not found: {dir_path}")
            return jsonify({
                'verified': False,
                'error': 'Directory not found',
                'finalFilename': os.path.basename(file_path),
                'newHash': 'Verification Failed'
            }), 200

        # Find metadata file in the directory
        metadata_files = [f for f in os.listdir(dir_path) if f.endswith('_metadata.json')]
        if not metadata_files:
            current_app.logger.error(f"No metadata file found in {dir_path}")
            return jsonify({
                'verified': False,
                'error': 'Metadata file not found',
                'finalFilename': os.path.basename(file_path),
                'newHash': 'Verification Failed'
            }), 200

        # Read metadata file
        metadata_path = os.path.join(dir_path, metadata_files[0])
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)

        # Get verification information from metadata
        result = {
            'verified': metadata.get('verified', False),
            'originalHash': metadata.get('originalFileHash', ''),
            'newHash': metadata.get('fileHash', ''),
            'finalFilename': metadata.get('final_filename', os.path.basename(file_path)),
            'error': None if metadata.get('verified', False) else 'Hash verification failed'
        }
        
        current_app.logger.info(f"Verification completed. Result: {result}")
        return jsonify(result), 200
        
    except Exception as e:
        current_app.logger.error(f"Verification error: {str(e)}")
        current_app.logger.error(traceback.format_exc())
        return jsonify({
            'verified': False,
            'error': str(e),
            'finalFilename': 'Error',
            'newHash': 'Verification Failed',
            'originalHash': 'Error'
        }), 200



project\client_app\routes\upload\__init__.py
============================================
# project/client_app/routes/upload/__init__.py
"""Upload routes package initialization."""

from flask import Blueprint, request
from .upload_controller import upload_routes
from .verification_controller import verification_routes
from .hash_controller import hash_routes

def create_upload_blueprint():
    """Create and configure the upload blueprint with all routes."""
    upload_blueprint = Blueprint('upload', __name__, url_prefix='/upload')
    
    # Register all route blueprints without additional URL prefix
    upload_blueprint.register_blueprint(upload_routes)
    upload_blueprint.register_blueprint(verification_routes)
    upload_blueprint.register_blueprint(hash_routes)
    
    return upload_blueprint


project\client_app\utils\cleanup_utils.py
=========================================
# project/client_app/utils/cleanup_utils.py
"""Cleanup utility functions."""

import os
from datetime import datetime
from flask import current_app

def clean_temp_files(temp_dir: str, max_age_hours: int = 24) -> None:
    """
    Clean up old temporary files.
    
    Args:
        temp_dir (str): Temporary directory path
        max_age_hours (int): Maximum age of files in hours before deletion
    """
    try:
        if not os.path.exists(temp_dir):
            return

        current_time = datetime.now().timestamp()
        max_age_seconds = max_age_hours * 3600

        for filename in os.listdir(temp_dir):
            filepath = os.path.join(temp_dir, filename)
            if os.path.isfile(filepath):
                file_modified = os.path.getmtime(filepath)
                if current_time - file_modified > max_age_seconds:
                    try:
                        os.remove(filepath)
                        current_app.logger.info(f"Cleaned up old temp file: {filepath}")
                    except OSError as e:
                        current_app.logger.error(f"Error deleting temp file {filepath}: {str(e)}")

    except Exception as e:
        current_app.logger.error(f"Error cleaning temp files: {str(e)}")


project\client_app\utils\directory_utils.py
===========================================
# project/client_app/utils/directory_utils.py
"""Directory manipulation utilities."""

import os
from flask import current_app

def ensure_dir_exists(directory: str) -> None:
    """
    Ensure a directory exists, create it if it doesn't.
    
    Args:
        directory (str): Path to the directory
    
    Raises:
        OSError: If directory creation fails due to permissions or disk space
    """
    try:
        if not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)
            current_app.logger.info(f"Created directory: {directory}")
    except OSError as e:
        current_app.logger.error(f"Failed to create directory {directory}: {str(e)}")
        raise

def get_temp_dir() -> str:
    """
    Get the temporary directory path, create if it doesn't exist.
    
    Returns:
        str: Path to temporary directory
    
    Raises:
        ValueError: If UPLOAD_FOLDER is not configured
    """
    if not current_app.config.get('UPLOAD_FOLDER'):
        raise ValueError("UPLOAD_FOLDER not configured in application settings")
    
    temp_dir = os.path.join(current_app.config['UPLOAD_FOLDER'], 'temp')
    ensure_dir_exists(temp_dir)
    return temp_dir

def is_path_secure(path: str, base_path: str) -> bool:
    """
    Check if a path is secure (doesn't escape base path).
    
    Args:
        path (str): Path to check
        base_path (str): Base path that should contain the path
        
    Returns:
        bool: True if path is secure, False otherwise
    """
    try:
        resolved_path = os.path.realpath(path)
        resolved_base = os.path.realpath(base_path)
        return resolved_path.startswith(resolved_base)
    except Exception as e:
        current_app.logger.error(f"Error checking path security: {str(e)}")
        return False

def create_folder_structure(base_folder: str, subfolder: str) -> str:
    """
    Create a folder structure and return the path.
    
    Args:
        base_folder (str): Base folder path
        subfolder (str): Subfolder name or path
        
    Returns:
        str: Complete folder path
    """
    folder_path = os.path.join(base_folder, subfolder)
    ensure_dir_exists(folder_path)
    return folder_path


project\client_app\utils\file_utils.py
======================================
# project/client_app/utils/file_utils.py
"""File-related utility functions."""

import os
from typing import Optional, Dict, Any
from flask import current_app
from datetime import datetime
from werkzeug.utils import secure_filename
from .format_utils import format_file_size

def get_metadata_path(upload_folder: str, filename: str) -> str:
    """
    Get the path for a metadata file.
    
    Args:
        upload_folder (str): Base upload folder path
        filename (str): Original filename
        
    Returns:
        str: Full path to metadata file
    """
    return os.path.join(upload_folder, f"{filename}_metadata.json")

def find_metadata_file(base_folder: str, filename: str) -> Optional[str]:
    """
    Find a metadata file in the base folder and its subdirectories.
    
    Args:
        base_folder (str): Base folder to search in
        filename (str): Original filename
        
    Returns:
        Optional[str]: Path to metadata file if found, None otherwise
    """
    metadata_filename = f"{filename}_metadata.json"
    for root, _, files in os.walk(base_folder):
        if metadata_filename in files:
            return os.path.join(root, metadata_filename)
    return None

def clean_filename(filename: str) -> str:
    """
    Clean and secure a filename.
    
    Args:
        filename (str): Original filename
        
    Returns:
        str: Cleaned and secured filename
    """
    return secure_filename(filename)

def get_file_extension(filename: str) -> str:
    """
    Get the file extension.
    
    Args:
        filename (str): Filename to process
        
    Returns:
        str: File extension including the dot
    """
    return os.path.splitext(filename)[1].lower()

def get_file_info(filepath: str) -> Dict[str, Any]:
    """
    Get detailed file information.
    
    Args:
        filepath (str): Path to the file
        
    Returns:
        Dict[str, Any]: Dictionary containing file information
    """
    try:
        stat = os.stat(filepath)
        return {
            'size': stat.st_size,
            'created': datetime.fromtimestamp(stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S'),
            'modified': datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
            'filename': os.path.basename(filepath),
            'extension': get_file_extension(filepath),
            'path': filepath,
            'formatted_size': format_file_size(stat.st_size)
        }
    except Exception as e:
        current_app.logger.error(f"Error getting file info: {str(e)}")
        return {}


project\client_app\utils\format_utils.py
========================================
# project/client_app/utils/format_utils.py
"""Formatting utility functions."""

def format_file_size(size_in_bytes: int) -> str:
    """
    Format file size in human-readable format.
    
    Args:
        size_in_bytes (int): File size in bytes
        
    Returns:
        str: Formatted file size string (e.g., "1.5 MB")
    """
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_in_bytes < 1024.0:
            return f"{size_in_bytes:.2f} {unit}"
        size_in_bytes /= 1024.0
    return f"{size_in_bytes:.2f} PB"


project\client_app\utils\path_utils.py
======================================
# project/client_app/utils/path_utils.py
"""Path manipulation utilities."""

import os
from typing import Dict, Any
from datetime import datetime
from werkzeug.utils import secure_filename
from .directory_utils import ensure_dir_exists

def get_folder_path(base_folder: str, metadata: Dict[str, Any]) -> str:
    """
    Generate folder path based on metadata.
    
    Args:
        base_folder (str): Base folder path
        metadata (Dict[str, Any]): File metadata
        
    Returns:
        str: Complete folder path
    """
    folder_name = metadata.get('folder_name', datetime.now().strftime("%Y%m%d_%H%M%S"))
    folder_path = os.path.join(base_folder, folder_name)
    ensure_dir_exists(folder_path)
    return folder_path

def generate_unique_filename(original_filename: str, prefix: str = "") -> str:
    """
    Generate a unique filename with timestamp.
    
    Args:
        original_filename (str): Original file name
        prefix (str): Optional prefix to add to filename
        
    Returns:
        str: Unique filename
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    base, ext = os.path.splitext(secure_filename(original_filename))
    if prefix:
        return f"{prefix}_{base}_{timestamp}{ext}"
    return f"{base}_{timestamp}{ext}"


project\client_app\utils\__init__.py
====================================
# project/client_app/utils/__init__.py
"""Utils package initialization."""

from typing import Dict, Any, Optional

from .directory_utils import (
    ensure_dir_exists,
    get_temp_dir,
    is_path_secure,
    create_folder_structure
)
from .file_utils import (
    get_metadata_path,
    find_metadata_file,
    clean_filename,
    get_file_extension,
    get_file_info
)
from .path_utils import (
    get_folder_path,
    generate_unique_filename
)
from .format_utils import format_file_size
from .cleanup_utils import clean_temp_files

__all__ = [
    'ensure_dir_exists',
    'get_temp_dir',
    'is_path_secure',
    'create_folder_structure',
    'get_metadata_path',
    'find_metadata_file',
    'clean_filename',
    'get_file_extension',
    'get_file_info',
    'get_folder_path',
    'generate_unique_filename',
    'format_file_size',
    'clean_temp_files'
]


project\static\css\custom.css
=============================
/* custom.css */

.modal-dialog {
    max-width: 80%; /* Increase modal width */
    width: 800px; /* Set a fixed width */
}

.modal-body {
    max-height: 70vh; /* Set maximum height */
    overflow-y: auto; /* Allow vertical scrolling if content exceeds max-height */
}

.confirmation-table {
    width: 100%;
    font-size: 0.9rem; /* Reduce font size slightly */
}

.confirmation-table th {
    white-space: nowrap;
    padding: 8px 4px;
}
.confirmation-table td {
    max-width: 200px; /* Set maximum width for cells */
    overflow-wrap: break-word; /* Allow long words to break and wrap */
    word-wrap: break-word; /* For older browsers */
    word-break: break-word; /* Allow breaking of non-English words */
}

.confirmation-table .from-value {
    max-width: 300px; /* Give more space for the 'From Value' column */
}

.confirmation-table .reviewed-column {
    width: 90px; /* Set a fixed width for the 'Reviewed' column */
    text-align: center;
}


project\static\css\history.css
==============================
/* Filenames section */
.filenames-section {
    width: 35%;
    padding: 0.75rem;
    font-family: monospace;
    border-right: 1px solid #e5e7eb;
}

.filename-container {
    margin-bottom: 0.5rem;
}

.filename-label {
    font-weight: 600;
    color: #374151;
    font-size: 0.75rem;
    margin-bottom: 0.25rem;
}

.filename-value {
    font-family: monospace;
    color: #374151;
    font-size: 0.85rem;
    line-height: 1.4;
    word-break: break-all;
    word-wrap: break-word;
    background: #f9fafb;
    padding: 0.5rem;
    border-radius: 4px;
    border: 1px solid #e5e7eb;
}

.original-filename,
.new-filename {
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    color: #374151;
    font-size: 0.85rem;
    line-height: 1.5;
}

/* Folder card styling */
.folder-card {
    padding: 0.5rem;
    margin-bottom: 1rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border: 1px solid #e5e7eb;
    position: relative;
}

.folder-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

/* Folder content */
.folder-content {
    display: flex;
    align-items: center;
    padding: 1rem;
    gap: 1rem;
    min-height: 120px;
    align-items: stretch;
}

/* Section styling */
.section {
    padding: 0 0.5rem;
}

/* Operation section */
.operation-section {
    width: 20%;
    border-right: 1px solid #e5e7eb;
}

.operation-name {
    font-weight: 600;
    color: #111827;
    margin-bottom: 0.25rem;
    font-size: 0.95rem;
}

.operation-date {
    font-size: 0.8rem;
    color: #6b7280;
}

/* Status section */
.status-section {
    width: 25%;
    text-align: right;
    border-right: 1px solid #e5e7eb;
    padding-right: 1rem;
}

.file-size {
    color: #ef4444;
    font-weight: 500;
    font-size: 0.85rem;
}

.item-number {
    color: #3b82f6;
    font-size: 0.85rem;
    margin-top: 0.25rem;
}

/* Buttons section */
.buttons-section {
    width: 20%;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    padding-right: 0.5rem;
}

.buttons-group {
    display: flex;
    gap: 0.35rem;
    justify-content: flex-end;
    margin-bottom: 0.25rem;
}

/* Button styles */
.info-button,
.resend-button,
.delete-button {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all 0.2s ease;
    border: 1px solid transparent;
    cursor: pointer;
    min-width: 60px;
    text-align: center;
}

.info-button .icon,
.delete-button .icon,
.resend-button .icon {
    font-size: 0.9em;
}

.info-button {
    background: #f3f4f6;
    color: #374151;
    border-color: #d1d5db;
}

.info-button:hover {
    background: #e5e7eb;
}

.resend-button {
    background: #dbeafe;
    color: #1e40af;
    border-color: #93c5fd;
}

.resend-button:hover {
    background: #bfdbfe;
}

.delete-button {
    background: #fee2e2;
    color: #dc2626;
    border-color: #fecaca;
}

.delete-button:hover {
    background: #fecaca;
}

/* Verification status */
.verification-status {
    font-size: 0.8rem;
    font-weight: 600;
    padding: 0.2rem 0;
}

.text-green {
    color: #10b981;
}

.text-red {
    color: #ef4444;
}

/* Verification badge */
.verification-badge {
    padding: 0.15rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 500;
    cursor: help;
    margin-top: 0.25rem;
    transition: all 0.2s ease;
    display: inline-block;
}

.verification-badge.verified {
    background-color: #dcfce7;
    color: #166534;
    border: 1px solid #bbf7d0;
}

.verification-badge.not-verified {
    background-color: #fee2e2;
    color: #991b1b;
    border: 1px solid #fecaca;
}

/* Tooltip for verification badge */
.verification-badge[data-tooltip] {
    position: relative;
}

.verification-badge[data-tooltip]:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    right: 0;
    top: 100%;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    white-space: nowrap;
    z-index: 1000;
    margin-top: 5px;
}

.verification-badge[data-tooltip]:hover::before {
    content: '';
    position: absolute;
    right: 15px;
    top: 100%;
    border: 5px solid transparent;
    border-bottom-color: rgba(0, 0, 0, 0.8);
    transform: translateY(-5px);
    z-index: 1000;
}

/* Search box styling */
.search-container {
    position: relative;
    margin-bottom: 2rem;
}

.search-input {
    width: 100%;
    padding: 0.75rem 1rem;
    padding-left: 2.5rem;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    font-size: 1rem;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.search-input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.search-icon {
    position: absolute;
    left: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    color: #9ca3af;
    pointer-events: none;
}

/* Modal close button */
.modal-close {
    background: none;
    border: none;
    padding: 0.5rem;
    cursor: pointer;
    color: #6b7280;
}

.modal-close:hover {
    color: #374151;
}

.modal-close .icon {
    font-size: 1.2em;
}



project\static\js\chunked-upload.js
===================================
// chunked-upload.js

const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB chunks
const MAX_RETRIES = 3; // Maximum number of retry attempts for failed chunks

async function uploadFile(file, metadata, progressCallback, abortSignal) {
    const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
    let uploadedChunks = 0;
    let finalResponse = null;

    // Handle abort signal
    if (abortSignal) {
        if (abortSignal.aborted) {
            throw new DOMException('Upload cancelled by user', 'AbortError');
        }

        abortSignal.addEventListener('abort', () => {
            throw new DOMException('Upload cancelled by user', 'AbortError');
        });
    }

    for (let start = 0; start < file.size; start += CHUNK_SIZE) {
        // Check for cancellation before each chunk
        if (abortSignal?.aborted) {
            throw new DOMException('Upload cancelled by user', 'AbortError');
        }

        const chunk = file.slice(start, start + CHUNK_SIZE);
        const formData = new FormData();
        formData.append('file', chunk, file.name);
        formData.append('chunk', uploadedChunks);
        formData.append('totalChunks', totalChunks);
        formData.append('chunkSize', CHUNK_SIZE);
        
        if (uploadedChunks === 0) {
            formData.append('metadata', JSON.stringify(metadata));
        }

        let retries = 0;
        while (retries < MAX_RETRIES) {
            try {
                // Check for cancellation before each retry
                if (abortSignal?.aborted) {
                    throw new DOMException('Upload cancelled by user', 'AbortError');
                }

                console.log(`Uploading chunk ${uploadedChunks + 1}/${totalChunks}`);
                const response = await fetch('/upload/upload-chunk', {  // Updated URL path
                    method: 'POST',
                    body: formData,
                    signal: abortSignal
                });

                if (!response.ok) {
                    const responseText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, body: ${responseText}`);
                }

                const result = await response.json();
                console.log('Chunk upload result:', result);

                if (result.error) {
                    throw new Error(result.error);
                }

                // Store the final response when it's the last chunk
                if (uploadedChunks === totalChunks - 1) {
                    finalResponse = result;
                }

                uploadedChunks++;
                const progress = (uploadedChunks / totalChunks) * 100;
                progressCallback(progress);
                
                break; // Successful upload, break the retry loop

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Upload aborted by user');
                    throw error; // Re-throw abort errors
                }
                
                retries++;
                console.error(`Chunk upload failed (attempt ${retries}/${MAX_RETRIES}):`, error);
                
                if (retries === MAX_RETRIES) {
                    console.error('Max retries reached for chunk upload');
                    throw error;
                }
                
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retries)));
            }
        }
    }

    // Final cancellation check
    if (abortSignal?.aborted) {
        throw new DOMException('Upload cancelled by user', 'AbortError');
    }

    if (!finalResponse) {
        throw new Error('No final response received from server');
    }

    return {
        status: 'Upload completed',
        totalChunks: totalChunks,
        filePath: finalResponse.filePath,
        success: true,
        ...finalResponse
    };
}

// Make uploadFile available globally
window.uploadFile = uploadFile;


project\static\js\components\DeleteConfirmationModal.js
=======================================================
// project/static/js/components/DeleteConfirmationModal.js

import React, { useState } from 'react';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertTriangle } from "lucide-react";

export default function DeleteConfirmationModal({ isOpen, onClose, onConfirm, folderPath }) {
    const [confirmText, setConfirmText] = useState('');
    const [error, setError] = useState('');

    const handleConfirm = () => {
        if (confirmText.trim() !== 'I Agree') {
            setError('Please type "I Agree" exactly to confirm deletion');
            return;
        }
        setError('');
        onConfirm();
    };

    return (
        <AlertDialog open={isOpen} onOpenChange={onClose}>
            <AlertDialogContent className="max-w-2xl">
                <AlertDialogHeader>
                    <AlertDialogTitle className="text-red-600 flex items-center gap-2">
                        <AlertTriangle className="h-5 w-5" />
                        Permanent Deletion Warning
                    </AlertDialogTitle>
                    <Alert variant="destructive" className="mb-4">
                        <AlertDescription className="font-semibold">
                            You are about to delete: {folderPath}
                        </AlertDescription>
                    </Alert>
                    <AlertDialogDescription className="space-y-4">
                        <p className="font-bold text-red-600">
                            WARNING: This action cannot be undone!
                        </p>
                        <p>
                            All data in this folder will be permanently deleted. This data will be:
                        </p>
                        <ul className="list-disc pl-6 space-y-2">
                            <li>Completely and permanently erased</li>
                            <li>Impossible to recover</li>
                            <li>Removed from all backups</li>
                            <li>Gone forever and ever</li>
                        </ul>
                        <div className="mt-6">
                            <label className="block text-sm font-medium mb-2">
                                Type "I Agree" to confirm deletion:
                            </label>
                            <input
                                type="text"
                                className="w-full px-3 py-2 border rounded-md"
                                value={confirmText}
                                onChange={(e) => setConfirmText(e.target.value)}
                                placeholder="Type 'I Agree'"
                            />
                            {error && (
                                <p className="mt-2 text-sm text-red-600">{error}</p>
                            )}
                        </div>
                    </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                    <AlertDialogCancel>Cancel</AlertDialogCancel>
                    <AlertDialogAction
                        className="bg-red-600 hover:bg-red-700"
                        onClick={handleConfirm}
                    >
                        Delete Forever
                    </AlertDialogAction>
                </AlertDialogFooter>
            </AlertDialogContent>
        </AlertDialog>
    );
}


project\static\js\core\utils.js
===============================
// project/static/js/core/utils.js

/**
 * Shared utility functions for the application
 */

const utils = {
    /**
     * Format file size in human-readable format
     * @param {number} bytes - File size in bytes
     * @returns {string} Formatted file size string
     */
    formatFileSize: function(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },

    /**
     * Check if a file size is within the allowed limit
     * @param {number} fileSize - File size in bytes
     * @param {number} maxSize - Maximum allowed size in bytes
     * @returns {boolean} True if file is within size limit
     */
    checkFileSize: function(fileSize, maxSize) {
        return fileSize <= maxSize;
    },

    /**
     * Generate a formatted timestamp
     * @returns {string} Formatted timestamp string
     */
    getTimestamp: function() {
        return new Date().toLocaleTimeString('en-US', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit' 
        }).replace(':', '');
    },

    /**
     * Clean filename by removing invalid characters
     * @param {string} filename - Original filename
     * @returns {string} Cleaned filename
     */
    cleanFilename: function(filename) {
        return filename.replace(/[^a-z0-9_.-]/gi, '_');
    },

    /**
     * Get file extension from filename
     * @param {string} filename - Filename to process
     * @returns {string} File extension including dot
     */
    getFileExtension: function(filename) {
        const lastDotIndex = filename.lastIndexOf('.');
        return lastDotIndex !== -1 ? filename.substring(lastDotIndex) : '';
    }
};

// Export utilities to global scope
window.utils = utils;


project\static\js\file-processing\cancellation-handler.js
=========================================================
// file-processing/cancellation-handler.js
const cancellationHandler = {
    async cancelUpload() {
        console.log('FileProcessing: Starting cancellation process');
        
        try {
            fileProcessingState.state.isCancelled = true;
            
            if (fileProcessingState.state.abortController) {
                fileProcessingState.state.abortController.abort();
            }
    
            if (fileProcessingState.state.currentFolderName) {
                console.log('FileProcessing: Cleaning up folder:', fileProcessingState.state.currentFolderName);
                
                try {
                    const response = await fetch('/cancel-upload', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            folder_name: fileProcessingState.state.currentFolderName
                        })
                    });
        
                    if (!response.ok) {
                        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                    }
                } catch (cleanupError) {
                    console.warn('FileProcessing: Cleanup warning:', cleanupError);
                    // Don't throw - continue with cancellation
                }
            }
    
            fileProcessingState.resetState();
            console.log('FileProcessing: Cancellation complete');
            
            modalHandlers.updateProgress('Upload cancelled', 'cancelled');
            return { success: true, message: 'Upload cancelled successfully' };
            
        } catch (error) {
            console.error('FileProcessing: Error during cancellation:', error);
            fileProcessingState.resetState();
            modalHandlers.updateProgress('Error during cancellation: ' + error.message, 'error');
            return { success: false, error: error.message };
        }
    }
};


project\static\js\file-processing\completion-handler.js
=======================================================
// file-processing/completion-handler.js
const completionHandler = {
    showCompletionStats(stats) {
        modalHandlers.showCompletionInfo({
            originalFile: stats.originalFile,
            newFile: stats.newFile,
            originalHash: stats.originalHash,
            newHash: stats.newHash,
            fileSize: stats.fileSize,
            verified: stats.verified,
            processingErrors: fileProcessingState.state.processingErrors
        });
    }
};



project\static\js\file-processing\error-handler.js
==================================================
// file-processing/error-handler.js
const errorHandler = {
    async handleError(error) {
        console.error('FileProcessing: Error occurred:', error);

        if (error.name !== 'AbortError' && fileProcessingState.state.currentFolderName) {
            try {
                await fetch('/cancel-upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_name: fileProcessingState.state.currentFolderName
                    })
                });
            } catch (cleanupError) {
                console.warn('FileProcessing: Cleanup after error failed:', cleanupError);
            }
        }

        fileProcessingState.resetState();
        
        if (error.name === 'AbortError') {
            throw error;
        }
        
        modalHandlers.updateProgress('Processing failed: ' + error.message, 'error');
        return {
            success: false,
            error: error.message
        };
    }
};


project\static\js\file-processing\hash-calculator.js
====================================================
// file-processing/hash-calculator.js
const hashCalculator = {
    async calculateHash(file) {
        try {
            modalHandlers.updateProgress('Calculating file hash...', 'calculating');
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('/upload/calculate-hash', {  // Updated URL
                method: 'POST',
                body: formData,
                signal: fileProcessingState.state.abortController.signal
            });

            if (!response.ok) {
                const errorMsg = `Hash calculation failed: Server returned ${response.status}: ${response.statusText}`;
                console.error(errorMsg);
                modalHandlers.updateProgress(errorMsg, 'error');
                // Don't throw - let the modal handler manage the error state
                return null;
            }

            const result = await response.json();
            if (result.error) {
                const errorMsg = `Hash calculation failed: ${result.error}`;
                console.error(errorMsg);
                modalHandlers.updateProgress(errorMsg, 'error');
                // Don't throw - let the modal handler manage the error state
                return null;
            }

            return result.hash;
        } catch (error) {
            console.error('Hash calculation failed:', error);
            const errorMsg = error.name === 'AbortError' 
                ? 'Hash calculation cancelled by user'
                : `Hash calculation failed: ${error.message}`;
            modalHandlers.updateProgress(errorMsg, 'error');
            // Don't throw - let the modal handler manage the error state
            return null;
        }
    }
};


project\static\js\file-processing\index.js
==========================================
// file-processing/index.js
const fileProcessing = {
    ...fileProcessingState,
    processFile: fileProcessor.processFile,
    calculateHash: hashCalculator.calculateHash,
    cancelUpload: cancellationHandler.cancelUpload,
    showCompletionStats: completionHandler.showCompletionStats
};

// Initialize the file processing module when the document is ready
document.addEventListener('DOMContentLoaded', function() {
    if (!window.fileProcessing) {
        window.fileProcessing = fileProcessing;
    }
    window.fileProcessing.resetState();
});

// Make fileProcessing available globally
window.fileProcessing = fileProcessing;


project\static\js\file-processing\processor.js
==============================================
// file-processing/processor.js
const fileProcessor = {
    async processFile(file, metadata) {
        try {
            // Reset state for new processing
            fileProcessingState.resetState();
            fileProcessingState.state.metadata = metadata;
            fileProcessingState.state.processingStatus = 'initializing';
            fileProcessingState.state.abortController = new AbortController();

            // Helper function to check for cancellation
            const checkCancellation = () => {
                if (fileProcessingState.state.isCancelled) {
                    throw new DOMException('Upload cancelled by user', 'AbortError');
                }
            };
            
            // Step 1: Create initial metadata file
            modalHandlers.updateProgress('Creating metadata file...', 'calculating');
            checkCancellation();
            fileProcessingState.state.metadata.createdAt = new Date().toISOString();
            fileProcessingState.state.metadata.processingStarted = new Date().toISOString();

            // Step 2: Calculate original file hash
            checkCancellation();
            modalHandlers.updateProgress('Calculating original file hash...', 'calculating');
            try {
                const fileHash = await hashCalculator.calculateHash(file);
                if (!fileHash) {
                    modalHandlers.updateProgress('Failed to calculate file hash', 'error');
                    return { success: false, error: 'Hash calculation failed' };
                }
                fileProcessingState.state.originalHash = fileHash;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw error;
                }
                modalHandlers.updateProgress(`Hash calculation failed: ${error.message}`, 'error');
                return { success: false, error: `Hash calculation failed: ${error.message}` };
            }

            // Step 3: Update metadata with original hash
            checkCancellation();
            modalHandlers.updateProgress('Updating metadata...', 'processing');
            fileProcessingState.state.metadata.originalFileHash = fileProcessingState.state.originalHash;
            fileProcessingState.state.metadata.originalFileName = file.name;
            fileProcessingState.state.metadata.fileSize = file.size;

            // Step 4: Create upload folder
            checkCancellation();
            modalHandlers.updateProgress('Creating upload folder...', 'processing');
            const folderName = fileProcessingState.state.metadata.folder_name;
            fileProcessingState.state.currentFolderName = folderName;

            // Step 5: Upload file in chunks
            checkCancellation();
            modalHandlers.updateProgress('Starting file transfer...', 0);
            let uploadResult;
            try {
                uploadResult = await fileUploader.uploadFileInChunks(file);
                if (!uploadResult.success) {
                    modalHandlers.updateProgress(uploadResult.error || 'Upload failed', 'error');
                    return { success: false, error: uploadResult.error || 'Upload failed' };
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw error;
                }
                modalHandlers.updateProgress(`Upload failed: ${error.message}`, 'error');
                return { success: false, error: `Upload failed: ${error.message}` };
            }

            // Step 6: Verify uploaded file
            checkCancellation();
            modalHandlers.updateProgress('Verifying uploaded file...', 'verifying');
            if (!uploadResult.verified) {
                const verifyError = 'File verification failed - hashes do not match';
                modalHandlers.updateProgress(verifyError, 'error');
                return { success: false, error: verifyError };
            }

            // Success - show completion info
            modalHandlers.updateProgress('Upload completed successfully!', 'success');
            modalHandlers.showCompletionInfo({
                originalFilename: file.name,
                newFilename: uploadResult.newFilename,
                filePath: uploadResult.filePath,
                originalHash: fileProcessingState.state.originalHash,
                newHash: uploadResult.newHash,
                fileSize: file.size,
                verified: uploadResult.verified,
                processingErrors: fileProcessingState.state.processingErrors
            });

            return {
                success: true,
                ...uploadResult
            };

        } catch (error) {
            console.error('File processing error:', error);
            fileProcessingState.state.processingErrors.push(error.message);
            
            if (error.name === 'AbortError') {
                modalHandlers.updateProgress('Upload cancelled by user', 'cancelled');
                return await cancellationHandler.cancelUpload();
            }
            
            modalHandlers.updateProgress(`Processing failed: ${error.message}`, 'error');
            return {
                success: false,
                error: error.message
            };
        }
    }
};

// Export the processor
window.fileProcessor = fileProcessor;


project\static\js\file-processing\state.js
==========================================
// file-processing/state.js
const fileProcessingState = {
    state: {
        currentUpload: null,
        currentFolderName: null,
        metadata: null,
        processingStatus: null,
        currentFilePath: null,
        originalHash: null,
        processingErrors: [],
        isCancelled: false,
        abortController: null
    },

    resetState() {
        console.log('FileProcessing: Resetting state');
        this.state = {
            currentUpload: null,
            currentFolderName: null,
            metadata: null,
            processingStatus: null,
            currentFilePath: null,
            originalHash: null,
            processingErrors: [],
            isCancelled: false,
            abortController: new AbortController()
        };
        console.log('FileProcessing: State reset complete');
    },

    getCurrentUpload() {
        return this.state.currentUpload;
    },

    getCurrentFolderName() {
        return this.state.currentFolderName;
    },

    setCurrentUpload(upload) {
        this.state.currentUpload = upload;
    },

    setCurrentFolderName(name) {
        this.state.currentFolderName = name;
    }
};


project\static\js\file-processing\uploader.js
=============================================
// file-processing/uploader.js
const fileUploader = {
    async uploadFileInChunks(file) {
        try {
            fileProcessingState.state.metadata.originalFileHash = fileProcessingState.state.originalHash;
            
            const result = await window.uploadFile(
                file,
                fileProcessingState.state.metadata,
                progress => modalHandlers.updateProgress('Uploading...', progress),
                fileProcessingState.state.abortController.signal
            );

            if (!result.success) {
                modalHandlers.updateProgress(result.error || 'Upload failed', 'error');
                return result;
            }

            return result;
        } catch (error) {
            if (error.name === 'AbortError') {
                modalHandlers.updateProgress('Upload cancelled', 'cancelled');
                throw error;
            }
            modalHandlers.updateProgress('Upload error: ' + error.message, 'error');
            return { success: false, error: error.message };
        }
    }
};


project\static\js\handlers\delete-handlers.js
=============================================
// project/static/js/handlers/delete-handlers.js

const deleteHandler = {
    init() {
        this.createDeleteModal();
    },

    createDeleteModal() {
        const modalHtml = `
            <div class="modal fade" id="deleteConfirmationModal" tabindex="-1" aria-labelledby="deleteConfirmationModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header bg-danger text-white">
                            <h5 class="modal-title" id="deleteConfirmationModalLabel">
                                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                                Warning: Permanent Deletion
                            </h5>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="alert alert-danger">
                                <strong>You are about to delete:</strong><br>
                                <span id="deleteFolderPath"></span>
                            </div>
                            <p class="fw-bold text-danger">WARNING: This action cannot be undone!</p>
                            <p>All data in this folder will be permanently deleted. This data will be:</p>
                            <ul>
                                <li>Completely and permanently erased</li>
                                <li>Impossible to recover</li>
                                <li>Removed from all backups</li>
                                <li>Gone forever and ever</li>
                            </ul>
                            <div class="mt-4">
                                <label class="form-label">Type "I Agree" to confirm deletion:</label>
                                <input type="text" class="form-control" id="deleteConfirmText" placeholder="Type 'I Agree'">
                                <div class="invalid-feedback" id="deleteConfirmError"></div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-danger" id="confirmDeleteBtn">Delete Forever</button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Add modal to body if it doesn't exist
        if (!$('#deleteConfirmationModal').length) {
            $('body').append(modalHtml);
        }
    },

    showDeleteConfirmation(folderPath, metadata) {
        $('#deleteFolderPath').text(folderPath);
        $('#deleteConfirmText').val('').removeClass('is-invalid');
        $('#deleteConfirmError').hide();

        $('#confirmDeleteBtn').off('click').on('click', async () => {
            const confirmText = $('#deleteConfirmText').val().trim();
            if (confirmText !== 'I Agree') {
                $('#deleteConfirmText').addClass('is-invalid');
                $('#deleteConfirmError').text('Please type "I Agree" exactly as shown').show();
                return;
            }

            try {
                await this.handleDelete(folderPath, metadata);
                bootstrap.Modal.getInstance($('#deleteConfirmationModal')).hide();
                // Refresh the folders list
                await historyHandlers.loadFolders();
            } catch (error) {
                console.error('Delete error:', error);
                $('#deleteConfirmError').text('Error deleting folder: ' + error.message).show();
            }
        });

        new bootstrap.Modal($('#deleteConfirmationModal')).show();
    },

    async handleDelete(folderPath, metadata) {
        try {
            const response = await fetch('/api/delete-folder', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    folder_path: folderPath,
                    metadata: metadata
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to delete folder');
            }
        } catch (error) {
            console.error('Delete error:', error);
            throw error;
        }
    }
};

// Initialize delete handler when document is ready
$(document).ready(() => {
    deleteHandler.init();
});

// Make deleteHandler available globally
window.deleteHandler = deleteHandler;


project\static\js\handlers\form-handlers.js
===========================================
// handlers/form-handlers.js
const formHandlers = {
    isSubmitting: false,

    initialize() {
        console.log('Initializing form handlers...');
        this.bindEventHandlers();
        this.initializeFormState();
    },

    initializeFormState() {
        console.log('Setting initial form state...');
        $('#processingMethod').val('Normal');
        const today = new Date().toISOString().split('T')[0];
        $('#dateOfCollection').val(today);
    },

    bindEventHandlers() {
        console.log('Binding event handlers...');
        
        // Pre-fill button handler
        $('#preFill').off('click').on('click', (e) => {
            console.log('Pre-fill button clicked');
            e.preventDefault();
            this.handlePreFill();
        });

        // File input handler
        $('#selectFile').off('change').on('change', () => {
            this.handleFileSelect();
        });

        // Form field change handlers
        $('#operation, #itemNumber, #subNumber, #deviceType, #dateOfCollection')
            .off('input change')
            .on('input change', () => {
                this.updateRenamePreview();
            });

        // Rename checkbox handler
        $('#renameFileCheck').off('change').on('change', () => {
            this.updateRenamePreview();
        });

        // Submit button handler
        $('#openConfirmationModal').off('click').on('click', (e) => {
            this.handleOpenConfirmationModal(e);
        });

        // Review checkboxes handler
        $(document).off('change', '.review-checkbox').on('change', '.review-checkbox', () => {
            this.updateSubmitButtonState();
        });

        // Cancel handlers
        $('#cancelReview').off('click').on('click', () => {
            modalHandlers.hideConfirmationModal();
        });

        $('#cancelUpload').off('click').on('click', () => {
            this.handleCancelUpload();
        });

        $('#completeButton').off('click').on('click', () => {
            // Don't auto-hide or redirect
            if (confirm('Are you sure you want to return to home?')) {
                modalHandlers.hideProgressModal();
                window.location.href = '/';
            }
        });

        this.initializeSecretSequence();
    },

    handlePreFill() {
        console.log('Executing pre-fill');
        $('#operation').val('Sample Operation');
        $('#deviceType').val('laptop');
        $('#serialNumber').val('12345');
        $('#itemNumber').val('001');
        $('#subNumber').val('1');
        $('#collection').val('red');
        $('#platform').val('red');
        $('#knownPasswords').val('password1,password2');
        $('#notes').val('Sample notes for data ingestion.');
        $('#processingMethod').val('Normal');
        
        this.updateRenamePreview();
    },

    handleFileSelect() {
        const fileInput = $('#selectFile')[0];
        if (fileInput.files.length > 0) {
            const file = fileInput.files[0];
            $('#fileName').val(file.name);
            $('#fileSize').text(utils.formatFileSize(file.size));
            this.updateRenamePreview();
            this.checkFileSize(file);
        } else {
            $('#fileName').val('');
            $('#fileSize').text('');
            $('#fileSizeMessage').text(`Maximum upload size is ${maxFileSizeGB} GB`);
        }
    },

    checkFileSize(file) {
        const fileSizeInGB = file.size / (1024 * 1024 * 1024);
        const maxFileSizeGB = window.maxFileSizeGB || 200;
        const fileSizeMessage = $('#fileSizeMessage');
        
        if (fileSizeInGB > maxFileSizeGB) {
            fileSizeMessage
                .text(`File is too large. Maximum size is ${maxFileSizeGB} GB. Your file is ${fileSizeInGB.toFixed(2)} GB.`)
                .addClass('text-danger');
            $('#selectFile').val('');
            $('#fileName').val('');
            $('#fileSize').text('');
            return false;
        } else {
            fileSizeMessage
                .text(`File size: ${utils.formatFileSize(file.size)} (Max: ${maxFileSizeGB} GB)`)
                .removeClass('text-danger');
            return true;
        }
    },

    updateRenamePreview() {
        console.log('Updating rename preview');
        const operation = $('#operation').val().replace(/\s+/g, '_');
        const itemNumber = $('#itemNumber').val();
        const subNumber = $('#subNumber').val();
        const deviceType = $('#deviceType').val();
        const collectionDate = $('#dateOfCollection').val();
        const fileInput = $('#selectFile')[0];
        let fileExtension = '';

        if (fileInput.files.length > 0) {
            const fileName = fileInput.files[0].name;
            const lastDotIndex = fileName.lastIndexOf('.');
            if (lastDotIndex !== -1) {
                fileExtension = fileName.substring(lastDotIndex);
            }
        }

        const renamePreview = `${operation}_${itemNumber}-${subNumber}_${deviceType}_${collectionDate}${fileExtension}`;
        console.log('New rename preview:', renamePreview);
        $('#renamePreview').val(renamePreview);
    },

    handleOpenConfirmationModal(e) {
        console.log('Handling confirmation modal open');
        e.preventDefault();
        
        if (!$('#selectFile')[0].files.length) {
            alert('Please select a file first');
            return;
        }

        if (!this.validateForm()) {
            return;
        }

        this.updateRenamePreview();
        modalHandlers.populateConfirmationModal();
        modalHandlers.showConfirmationModal();
    },

    validateForm() {
        const required = ['operation', 'deviceType', 'itemNumber', 'subNumber', 'dateOfCollection'];
        let isValid = true;

        required.forEach(fieldId => {
            const field = $(`#${fieldId}`);
            if (!field.val()) {
                alert(`Please fill in the ${fieldId.replace(/([A-Z])/g, ' $1').toLowerCase()}`);
                isValid = false;
            }
        });

        return isValid;
    },

    updateSubmitButtonState() {
        const totalCheckboxes = $('.review-checkbox').length;
        const checkedCheckboxes = $('.review-checkbox:checked').length;
        const allChecked = totalCheckboxes > 0 && checkedCheckboxes === totalCheckboxes;
        $('#confirmSubmit').prop('disabled', !allChecked);
    },

    handleCancelUpload() {
        if (!confirm('Are you sure you want to cancel the upload?')) {
            return;
        }

        const currentUpload = window.fileProcessing.getCurrentUpload();
        if (currentUpload) {
            modalHandlers.updateProgress('Cancelling upload...', 'calculating');
            currentUpload.abort();
        }
    },

    initializeSecretSequence() {
        console.log('Initializing secret sequence handler');
        let secretSequence = '';
        $(document).off('keypress').on('keypress', (e) => {
            secretSequence += String.fromCharCode(e.which);
            if (secretSequence.endsWith('xxx')) {
                console.log('Secret sequence activated!');
                $('.review-checkbox').prop('checked', true);
                this.updateSubmitButtonState();
                secretSequence = '';
            }
            if (secretSequence.length > 10) {
                secretSequence = '';
            }
        });
    },

    resetSubmissionState() {
        this.isSubmitting = false;
    },

    handleSubmissionError(error) {
        console.error('Submission error:', error);
        modalHandlers.updateProgress(error.message || 'Submission failed', 'error');
        this.isSubmitting = false;
    }
};

// Initialize handlers when document is ready
$(document).ready(() => {
    console.log('Document ready - initializing form handlers');
    formHandlers.initialize();
});

// Make formHandlers available globally
window.formHandlers = formHandlers;


project\static\js\handlers\history-handlers.js
==============================================
// handlers/history-handlers.js
const historyHandlers = {
    folders: [],
    currentMetadata: null,

    init() {
        this.bindEventListeners();
        this.loadFolders();
    },

    bindEventListeners() {
        // Search box handler
        $('#searchBox').on('input', (e) => this.handleSearch(e.target.value));

        // Event delegation for dynamically created elements
        $(document).on('click', '.info-button', (e) => {
            e.preventDefault();
            const $card = $(e.target).closest('.folder-card');
            const metadata = $card.data('metadata');
            this.showMetadataInfo(metadata);
        });

        $(document).on('click', '.resend-button', (e) => {
            e.preventDefault();
            const $card = $(e.target).closest('.folder-card');
            const inventory = $card.data('inventory');
            this.handleResendClick(inventory, $card.data('metadata'));
        });

        // Delete button handler
        $(document).on('click', '.delete-button', (e) => {
            e.preventDefault();
            const $card = $(e.target).closest('.folder-card');
            const metadata = $card.data('metadata');
            const folderPath = metadata.upload_folder;
            deleteHandler.showDeleteConfirmation(folderPath, metadata);
        });

        // Close modal handlers
        $(document).on('click', '.modal-close', function() {
            $(this).closest('.modal').modal('hide');
        });
    },

    async loadFolders() {
        try {
            const response = await fetch('/api/folders');
            if (!response.ok) {
                throw new Error('Failed to fetch folders');
            }
            
            this.folders = await response.json();
            console.log('Loaded folders:', this.folders);
            this.displayFolders(this.folders);
        } catch (error) {
            console.error('Error loading folders:', error);
            this.handleError(error);
        }
    },

    displayFolders(folders) {
        const folderList = $('#folderList');
        folderList.empty();
    
        folders.forEach(folder => {
            const hasInventory = folder.inventory && folder.inventory.length > 0;
            const verified = folder.metadata.verified;
            const verificationTooltip = verified ? 
                "Files were copied successfully and hash matched" : 
                "File verification failed or pending";
            
            const folderHtml = `
                <div class="folder-card" data-folder="${folder.name}">
                    <div class="folder-content">
                        <div class="section operation-section">
                            <div class="operation-name">${folder.metadata.operation || 'Unknown Operation'}</div>
                            <div class="operation-date">${folder.metadata.dateOfCollection || 'Unknown Date'}</div>
                        </div>
    
                        <div class="section filenames-section">
                            <div class="filename-container">
                                <div class="filename-label">Original Filename:</div>
                                <div class="filename-value" title="${folder.metadata.originalFilename || 'Unknown File'}">
                                    ${folder.metadata.originalFilename || 'Unknown File'}
                                </div>
                            </div>
                            <div class="filename-container">
                                <div class="filename-label">Changed Filename:</div>
                                <div class="filename-value" title="${folder.metadata.newFilename || 'N/A'}">
                                    ${folder.metadata.newFilename || 'N/A'}
                                </div>
                            </div>
                        </div>
    
                        <div class="section status-section">
                            <div class="file-size">
                                FILE SIZE: ${folder.metadata.fileSize ? 
                                    `${(folder.metadata.fileSize / (1024 * 1024 * 1024)).toFixed(2)} GB` : 
                                    'N/A'}
                            </div>
                            <div class="item-number">
                                Item NO: ${folder.metadata.itemNumber || ''} Sub ${folder.metadata.subNumber || ''}
                            </div>
                        </div>
    
                        <div class="section buttons-section">
                            <div class="buttons-group">
                                <button class="info-button">Info</button>
                                ${hasInventory ? '<button class="resend-button">Resend</button>' : ''}
                                <button class="delete-button">Delete</button>
                            </div>
                            <div class="verification-badge ${verified ? 'verified' : 'not-verified'}"
                                 data-tooltip="${verificationTooltip}">
                                ${verified ? 'Verified' : 'Not Verified'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
    
            const $card = $(folderHtml);
            $card.data({
                metadata: folder.metadata,
                inventory: folder.inventory
            });
    
            folderList.append($card);
        });
    },

    handleSearch(searchTerm) {
        const filteredFolders = searchTerm ? 
            this.folders.filter(folder => 
                JSON.stringify(folder.metadata).toLowerCase().includes(searchTerm.toLowerCase())
            ) : this.folders;
        
        this.displayFolders(filteredFolders);
    },

    showMetadataInfo(metadata) {
        if (!metadata) {
            this.handleError(new Error('No metadata available'));
            return;
        }

        let metadataHtml = '<div class="table-responsive"><table class="table table-bordered">';
        metadataHtml += `
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody>
        `;

        const sortedEntries = Object.entries(metadata).sort((a, b) => a[0].localeCompare(b[0]));

        for (const [key, value] of sortedEntries) {
            let displayValue = value;
            if (typeof value === 'boolean') {
                displayValue = value ? 'Yes' : 'No';
            } else if (value === null || value === undefined) {
                displayValue = 'N/A';
            } else if (typeof value === 'object') {
                displayValue = JSON.stringify(value, null, 2);
            }

            metadataHtml += `
                <tr>
                    <td class="fw-bold">${key}</td>
                    <td>${displayValue}</td>
                </tr>
            `;
        }

        metadataHtml += '</tbody></table></div>';
        $('#infoContent').html(metadataHtml);
        new bootstrap.Modal(document.getElementById('infoModal')).show();
    },

    async handleResendClick(inventory, metadata) {
        if (!inventory?.length) {
            this.handleError(new Error('No inventory data available'));
            return;
        }

        this.currentMetadata = metadata;
        const inventoryHtml = this.createInventoryTable(inventory);
        $('#inventoryContent').html(inventoryHtml);
        
        inventory.forEach(chunk => {
            $(`#resubmit-${chunk.chunk}`).data('chunk', chunk);
        });
        
        new bootstrap.Modal(document.getElementById('inventoryModal')).show();
    },

    createInventoryTable(inventory) {
        return `
            <div class="table-responsive">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>File</th>
                            <th>Chunk</th>
                            <th>Hash</th>
                            <th>Size</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${inventory.map(chunk => `
                            <tr>
                                <td>${chunk.file}</td>
                                <td>${chunk.chunk}</td>
                                <td class="text-monospace small">${chunk.hash}</td>
                                <td>${this.formatFileSize(chunk.size)}</td>
                                <td>
                                    <button id="resubmit-${chunk.chunk}" 
                                            class="btn btn-primary btn-sm resubmit-chunk-btn">
                                        Resubmit
                                    </button>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;
    },

    async handleChunkResubmit(chunk) {
        try {
            const response = await fetch('/api/resend-chunk', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chunk: chunk.chunk,
                    hash: chunk.hash,
                    size: chunk.size,
                    metadata: this.currentMetadata
                })
            });

            if (!response.ok) {
                throw new Error(`Server returned ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            if (result.error) {
                throw new Error(result.error);
            }

            // Show success message without redirect
            const successHtml = `
                <div class="alert alert-success">
                    <h5>Resend Request Created</h5>
                    <p>Location: ${result.location}</p>
                    <p>Filename: ${result.filename}</p>
                    <button class="btn btn-primary" onclick="$('#inventoryModal').modal('hide')">
                        Close
                    </button>
                </div>
            `;
            $('#inventoryContent').html(successHtml);

        } catch (error) {
            console.error('Resend error:', error);
            this.handleError(error);
        }
    },

    handleError(error) {
        console.error('History error:', error);
        const errorMessage = error.message || 'An error occurred';
        
        // Show error in modal if open, otherwise in alert
        if ($('#infoModal').hasClass('show')) {
            $('#infoContent').html(`
                <div class="alert alert-danger">
                    <strong>Error:</strong> ${errorMessage}
                    <button class="btn btn-primary mt-3" onclick="$('#infoModal').modal('hide')">
                        Close
                    </button>
                </div>
            `);
        } else if ($('#inventoryModal').hasClass('show')) {
            $('#inventoryContent').html(`
                <div class="alert alert-danger">
                    <strong>Error:</strong> ${errorMessage}
                    <button class="btn btn-primary mt-3" onclick="$('#inventoryModal').modal('hide')">
                        Close
                    </button>
                </div>
            `);
        } else {
            // Create and show error modal
            const errorModal = `
                <div class="modal fade" id="errorModal" tabindex="-1">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header bg-danger text-white">
                                <h5 class="modal-title">Error</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <div class="alert alert-danger mb-0">
                                    ${errorMessage}
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing error modal if present
            $('#errorModal').remove();
            
            // Add new error modal to body and show it
            $('body').append(errorModal);
            new bootstrap.Modal(document.getElementById('errorModal')).show();
        }
    },

    formatFileSize(bytes) {
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        if (bytes === 0) return '0 Bytes';
        const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
        return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
    },

    bindResubmitHandlers() {
        $(document).on('click', '.resubmit-chunk-btn', async (e) => {
            e.preventDefault();
            const button = $(e.target);
            const chunk = button.data('chunk');
            
            // Disable button and show loading state
            button.prop('disabled', true)
                  .html('<span class="spinner-border spinner-border-sm"></span> Resubmitting...');
            
            try {
                await this.handleChunkResubmit(chunk);
            } catch (error) {
                this.handleError(error);
            } finally {
                button.prop('disabled', false).text('Resubmit');
            }
        });
    }
};

// Initialize handlers when document is ready
$(document).ready(() => {
    console.log('Initializing history handlers...');
    historyHandlers.init();
    historyHandlers.bindResubmitHandlers();
});

// Make historyHandlers available globally
window.historyHandlers = historyHandlers;


project\static\js\handlers\modal-handlers.js
============================================
// modal-handlers.js

const modalHandlers = {
    state: {
        isProgressModalShown: false,
        isConfirmationModalShown: false,
        currentProgress: 0,
        processingStatus: null,
        isUploading: false
    },

    showProgressModal: function(initialMessage = 'Initializing...') {
        console.log('Showing progress modal with message:', initialMessage);
        
        try {
            const progressModal = new bootstrap.Modal(document.getElementById('progressModal'), {
                backdrop: 'static',
                keyboard: false
            });

            // Reset the progress bar state
            $('#progressBar')
                .css('width', '0%')
                .attr('aria-valuenow', 0)
                .removeClass('progress-bar-striped progress-bar-animated bg-danger bg-success')
                .addClass('bg-primary');
            
            // Reset text displays
            $('#progressText').text(initialMessage);
            $('#progressDetails').text('');
            
            // Reset completion info and buttons
            $('#completionInfo').addClass('d-none');
            $('#cancelUpload')
                .removeClass('d-none')
                .prop('disabled', false)
                .show();
            $('#completeButton').addClass('d-none');
            
            // Show the modal
            progressModal.show();
            this.state.isProgressModalShown = true;
            this.state.isUploading = true;

            // Bind cancel button event handler
            this.bindCancelHandler();

        } catch (error) {
            console.error('Error showing progress modal:', error);
            alert('Error initializing progress display. Please try again.');
        }
    },

    bindCancelHandler: function() {
        $('#cancelUpload').off('click').on('click', async (e) => {
            e.preventDefault();
            console.log('Cancel button clicked');
            
            const button = $('#cancelUpload');
            button.prop('disabled', true);
            
            try {
                this.updateProgress('Cancelling upload...', 'calculating');
                
                // Call the file processing cancel method
                if (window.fileProcessing) {
                    await window.fileProcessing.cancelUpload();
                    console.log('Cancel request processed');
                }
                
                // Update UI for cancelled state
                this.updateProgress('Upload cancelled', 'cancelled');
                button.addClass('d-none');
                $('#completeButton')
                    .removeClass('d-none')
                    .off('click')
                    .on('click', () => {
                        this.hideProgressModal();
                        window.location.href = '/';
                    });
                
            } catch (error) {
                console.error('Error during cancellation:', error);
                this.updateProgress('Error cancelling upload: ' + error.message, 'error');
            } finally {
                // Ensure button is re-enabled if needed
                button.prop('disabled', false);
            }
        });
    },

    updateProgress: function(message, progress) {
        console.log('Updating progress:', message, progress);
        
        try {
            const progressBar = $('#progressBar');
            const progressText = $('#progressText');
            const progressDetails = $('#progressDetails');
            const cancelButton = $('#cancelUpload');
            const completeButton = $('#completeButton');

            // Reset classes first
            progressBar.removeClass('progress-bar-striped progress-bar-animated bg-danger bg-success bg-primary');

            switch(progress) {
                case 'calculating':
                case 'verifying':
                case 'processing':
                    progressBar
                        .addClass('progress-bar-striped progress-bar-animated bg-primary')
                        .css('width', '100%')
                        .attr('aria-valuenow', 100);
                    progressDetails.text('');
                    cancelButton.prop('disabled', false).show();
                    break;

                case 'cancelled':
                    progressBar
                        .addClass('bg-warning')
                        .css('width', '100%')
                        .attr('aria-valuenow', 100);
                    cancelButton.addClass('d-none');
                    completeButton.removeClass('d-none')
                        .off('click')
                        .on('click', () => {
                            this.hideProgressModal();
                            window.location.href = '/';
                        });
                    progressDetails.text('Operation cancelled by user');
                    this.state.processingStatus = 'cancelled';
                    this.state.isUploading = false;
                    break;

                case 'failed':
                case 'error':
                    progressBar
                        .addClass('bg-danger')
                        .css('width', '100%')
                        .attr('aria-valuenow', 100);
                    cancelButton.addClass('d-none');
                    completeButton.removeClass('d-none');
                    progressDetails.text('An error occurred during processing');
                    this.state.processingStatus = 'error';
                    this.state.isUploading = false;
                    break;

                default:
                    if (typeof progress === 'number') {
                        this.state.currentProgress = progress;
                        progressBar
                            .addClass('bg-primary')
                            .css('width', `${Math.round(progress)}%`)
                            .attr('aria-valuenow', Math.round(progress));
                        message = `${message} ${Math.round(progress)}%`;
                        progressDetails.text('');
                        cancelButton.prop('disabled', false).show();
                    }
            }

            progressText.text(message);

        } catch (error) {
            console.error('Error updating progress display:', error);
        }
    },

    hideProgressModal: function() {
        try {
            const progressModal = bootstrap.Modal.getInstance(document.getElementById('progressModal'));
            if (progressModal) {
                progressModal.hide();
                this.state.isProgressModalShown = false;
                this.state.isUploading = false;
                
                // Redirect after modal is hidden
                setTimeout(() => {
                    window.location.href = '/';
                }, 100);
            }
        } catch (error) {
            console.error('Error hiding progress modal:', error);
            // Fallback redirect
            window.location.href = '/';
        }
    },
    showConfirmationModal: function() {
        console.log('Showing confirmation modal');
        try {
            const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'), {
                backdrop: 'static',
                keyboard: false
            });
            confirmationModal.show();
            this.state.isConfirmationModalShown = true;
            
            // Reset checkbox states
            $('.review-checkbox').prop('checked', false);
            $('#confirmSubmit').prop('disabled', true);

        } catch (error) {
            console.error('Error showing confirmation modal:', error);
            alert('Error showing confirmation dialog. Please try again.');
        }
    },

    hideConfirmationModal: function() {
        console.log('Hiding confirmation modal');
        try {
            const confirmationModal = bootstrap.Modal.getInstance(document.getElementById('confirmationModal'));
            if (confirmationModal) {
                confirmationModal.hide();
                this.state.isConfirmationModalShown = false;
            }
        } catch (error) {
            console.error('Error hiding confirmation modal:', error);
        }
    },

    hideProgressModal: function() {
        console.log('Hiding progress modal');
        try {
            const progressModal = bootstrap.Modal.getInstance(document.getElementById('progressModal'));
            if (progressModal) {
                progressModal.hide();
                this.state.isProgressModalShown = false;
                this.state.isUploading = false;
            }
        } catch (error) {
            console.error('Error hiding progress modal:', error);
        }
    },

    populateConfirmationModal: function() {
        console.log('Populating confirmation modal...');
        try {
            const fileInput = document.getElementById('selectFile');
            const fields = [
                { 
                    name: 'File', 
                    value: fileInput.files.length > 0 ? 
                        `${fileInput.files[0].name} (${utils.formatFileSize(fileInput.files[0].size)})` : 
                        'No file selected' 
                },
                { name: 'Operation', value: $('#operation').val() },
                { name: 'Device Type', value: $('#deviceType').val() },
                { name: 'Serial Number', value: $('#serialNumber').val() },
                { name: 'Item Number', value: $('#itemNumber').val() },
                { name: 'Sub Number', value: $('#subNumber').val() },
                { name: 'Collection', value: $('#collection').val() },
                { name: 'Platform', value: $('#platform').val() },
                { name: 'Date of Collection', value: $('#dateOfCollection').val() },
                { name: 'Known Passwords', value: $('#knownPasswords').val() },
                { name: 'Notes', value: $('#notes').val() },
                { name: 'Rename File', value: $('#renameFileCheck').is(':checked') ? 'Yes' : 'No' },
                { name: 'New File Name', value: $('#renamePreview').val() },
                { name: 'Processing Method', value: $('#processingMethod').val() }
            ];

            const confirmationTableBody = $('#confirmationTableBody');
            confirmationTableBody.empty();

            fields.forEach((field, index) => {
                const row = `<tr>
                    <td>${field.name}</td>
                    <td class="from-value">${field.value}</td>
                    <td class="reviewed-column">
                        <input type="checkbox" class="review-checkbox form-check-input" data-index="${index}">
                    </td>
                </tr>`;
                confirmationTableBody.append(row);
            });

            $('#confirmSubmit').prop('disabled', true);

        } catch (error) {
            console.error('Error populating confirmation modal:', error);
            alert('Error preparing confirmation dialog. Please try again.');
        }
    },

    showCompletionInfo: function(info) {
        console.log('Showing completion info:', info);
        try {
            $('#completionInfo').removeClass('d-none');
            
            const content = `
                <div class="completion-details p-3">
                    <h4 class="text-center mb-3">Processing Complete</h4>
                    
                    <div class="mb-2">
                        <strong>Original Filename:</strong> ${info.originalFilename}
                    </div>
                    
                    <div class="mb-2">
                        <strong>New Filename:</strong> ${info.newFilename}
                    </div>
                    
                    <div class="mb-2">
                        <strong>File Path:</strong> ${info.filePath || 'N/A'}
                    </div>
                    
                    <div class="mb-2">
                        <strong>Original Hash:</strong> 
                        <span class="font-monospace">${info.originalHash}</span>
                    </div>
                    
                    <div class="mb-2">
                        <strong>New Hash:</strong> 
                        <span class="font-monospace">${info.newHash}</span>
                    </div>

                    <div class="mb-2">
                        <strong>File Size:</strong> ${utils.formatFileSize(info.fileSize)}
                    </div>
                    
                    <div class="text-center mt-3">
                        <span class="badge ${info.verified ? 'bg-success' : 'bg-danger'} p-2">
                            ${info.verified ? 'Verification Successful' : 'Verification Failed'}
                        </span>
                    </div>

                    ${info.processingErrors.length > 0 ? `
                        <div class="mt-3 text-danger">
                            <strong>Errors:</strong>
                            <ul>
                                ${info.processingErrors.map(error => `<li>${error}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    <div class="text-center mt-3">
                        <button type="button" class="btn btn-primary" id="modalCompleteButton">
                            Complete
                        </button>
                    </div>
                </div>
            `;
            
            $('#completionInfo').html(content);
            
            const progressBar = $('#progressBar');
            progressBar
                .removeClass('bg-primary progress-bar-striped progress-bar-animated')
                .addClass(info.verified ? 'bg-success' : 'bg-danger')
                .css('width', '100%');
            
            $('#cancelUpload').addClass('d-none');
            $('#completeButton').addClass('d-none');
            
            // Add click handler for the complete button
            $('#modalCompleteButton').off('click').on('click', () => {
                this.hideProgressModal();
                window.location.href = '/';
            });
            
        } catch (error) {
            console.error('Error showing completion info:', error);
            this.updateProgress('Error displaying completion information', 'error');
        }
    },

    bindEventHandlers: function() {
        console.log('Binding modal event handlers...');

        // Cancel upload handler
        $('#cancelUpload').off('click').on('click', async (e) => {
            e.preventDefault();
            console.log('Cancel button clicked');
            
            const button = $('#cancelUpload');
            button.prop('disabled', true);
            
            try {
                if (!this.state.isUploading) {
                    console.log('No active upload to cancel');
                    return;
                }

                this.updateProgress('Cancelling upload...', 'calculating');
                
                if (!window.fileProcessing) {
                    throw new Error('File processing system not initialized');
                }

                await window.fileProcessing.cancelUpload();
                console.log('Upload cancelled successfully');
                
                this.updateProgress('Upload cancelled', 'cancelled');
                this.state.isUploading = false;
                
                button.addClass('d-none');
                $('#completeButton').removeClass('d-none')
                    .off('click')
                    .on('click', () => {
                        this.hideProgressModal();
                        window.location.href = '/';
                    });
                
            } catch (error) {
                console.error('Error cancelling upload:', error);
                this.updateProgress('Error cancelling upload: ' + error.message, 'error');
            } finally {
                button.prop('disabled', false);
            }
        });

        // Review checkbox handler
        $(document).off('change', '.review-checkbox').on('change', '.review-checkbox', () => {
            const totalCheckboxes = $('.review-checkbox').length;
            const checkedCheckboxes = $('.review-checkbox:checked').length;
            $('#confirmSubmit').prop('disabled', !(totalCheckboxes > 0 && checkedCheckboxes === totalCheckboxes));
        });

        // Debug check for button existence
        if ($('#cancelUpload').length === 0) {
            console.error('Cancel button not found in DOM');
        } else {
            console.log('Cancel button found and handler attached');
        }
    }
};

// Initialize modal handlers when document is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('Initializing modal handlers');
    modalHandlers.bindEventHandlers();
});

// Make modalHandlers available globally
window.modalHandlers = modalHandlers;


project\static\js\modal-handlers\confirmation-modal.js
======================================================
// modal-handlers/confirmation-modal.js
const confirmationModalHandler = {
    showConfirmationModal() {
        console.log('Showing confirmation modal');
        try {
            const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'), {
                backdrop: 'static',
                keyboard: false
            });
            confirmationModal.show();
            modalState.state.isConfirmationModalShown = true;
            
            // Reset checkbox states
            $('.review-checkbox').prop('checked', false);
            $('#confirmSubmit').prop('disabled', true);

        } catch (error) {
            console.error('Error showing confirmation modal:', error);
            alert('Error showing confirmation dialog. Please try again.');
        }
    },

    hideConfirmationModal() {
        console.log('Hiding confirmation modal');
        try {
            const confirmationModal = bootstrap.Modal.getInstance(document.getElementById('confirmationModal'));
            if (confirmationModal) {
                confirmationModal.hide();
                modalState.state.isConfirmationModalShown = false;
            }
        } catch (error) {
            console.error('Error hiding confirmation modal:', error);
        }
    },

    populateConfirmationModal() {
        console.log('Populating confirmation modal...');
        try {
            const fileInput = document.getElementById('selectFile');
            const fields = [
                { 
                    name: 'File', 
                    value: fileInput.files.length > 0 ? 
                        `${fileInput.files[0].name} (${utils.formatFileSize(fileInput.files[0].size)})` : 
                        'No file selected' 
                },
                { name: 'Operation', value: $('#operation').val() },
                { name: 'Device Type', value: $('#deviceType').val() },
                { name: 'Serial Number', value: $('#serialNumber').val() },
                { name: 'Item Number', value: $('#itemNumber').val() },
                { name: 'Sub Number', value: $('#subNumber').val() },
                { name: 'Collection', value: $('#collection').val() },
                { name: 'Platform', value: $('#platform').val() },
                { name: 'Date of Collection', value: $('#dateOfCollection').val() },
                { name: 'Known Passwords', value: $('#knownPasswords').val() },
                { name: 'Notes', value: $('#notes').val() },
                { name: 'Rename File', value: $('#renameFileCheck').is(':checked') ? 'Yes' : 'No' },
                { name: 'New File Name', value: $('#renamePreview').val() },
                { name: 'Processing Method', value: $('#processingMethod').val() }
            ];

            const confirmationTableBody = $('#confirmationTableBody');
            confirmationTableBody.empty();

            fields.forEach((field, index) => {
                const row = `<tr>
                    <td>${field.name}</td>
                    <td class="from-value">${field.value}</td>
                    <td class="reviewed-column">
                        <input type="checkbox" class="review-checkbox form-check-input" data-index="${index}">
                    </td>
                </tr>`;
                confirmationTableBody.append(row);
            });

            $('#confirmSubmit').prop('disabled', true);

        } catch (error) {
            console.error('Error populating confirmation modal:', error);
            alert('Error preparing confirmation dialog. Please try again.');
        }
    }
};


project\static\js\modal-handlers\index.js
=========================================
// modal-handlers/index.js
const modalHandlers = {
    ...modalState,
    ...progressModalHandler,
    ...confirmationModalHandler,
    ...modalCompletionHandler,

    initialize() {
        console.log('Initializing modal handlers');
        this.resetState();
        this.bindEventHandlers();
    },

    bindEventHandlers() {
        console.log('Binding modal event handlers...');

        // Review checkbox handler
        $(document).off('change', '.review-checkbox').on('change', '.review-checkbox', () => {
            const totalCheckboxes = $('.review-checkbox').length;
            const checkedCheckboxes = $('.review-checkbox:checked').length;
            $('#confirmSubmit').prop('disabled', !(totalCheckboxes > 0 && checkedCheckboxes === totalCheckboxes));
        });

        // Debug check for button existence
        if ($('#cancelUpload').length === 0) {
            console.error('Cancel button not found in DOM');
        } else {
            console.log('Cancel button found and handler attached');
        }
    }
};

// Initialize modal handlers when document is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('Initializing modal handlers');
    modalHandlers.initialize();
});

// Make modalHandlers available globally
window.modalHandlers = modalHandlers;


project\static\js\modal-handlers\modal-completion.js
====================================================
// modal-handlers/modal-completion.js
const modalCompletionHandler = {
    async showCompletionInfo(info) {
        console.log('Showing completion info:', info);
        try {
            $('#completionInfo').removeClass('d-none');
            
            const content = `
                <div class="completion-details p-3">
                    <h4 class="text-center mb-3">Processing Complete</h4>
                    
                    <div class="mb-2">
                        <strong>Original Filename:</strong> ${info.originalFilename}
                    </div>
                    
                    <div class="mb-2">
                        <strong>New Filename:</strong> ${info.newFilename}
                    </div>
                    
                    <div class="mb-2">
                        <strong>File Path:</strong> ${info.filePath || 'N/A'}
                    </div>
                    
                    <div class="mb-2">
                        <strong>Original Hash:</strong> 
                        <span class="font-monospace">${info.originalHash}</span>
                    </div>
                    
                    <div class="mb-2">
                        <strong>New Hash:</strong> 
                        <span class="font-monospace">${info.newHash}</span>
                    </div>

                    <div class="mb-2">
                        <strong>File Size:</strong> ${utils.formatFileSize(info.fileSize)}
                    </div>
                    
                    <div class="text-center mt-3">
                        <span class="badge ${info.verified ? 'bg-success' : 'bg-danger'} p-2">
                            ${info.verified ? 'Verification Successful' : 'Verification Failed'}
                        </span>
                    </div>

                    ${info.processingErrors.length > 0 ? `
                        <div class="mt-3 text-danger">
                            <strong>Errors:</strong>
                            <ul>
                                ${info.processingErrors.map(error => `<li>${error}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    <div class="text-center mt-3">
                        <button type="button" class="btn btn-primary" id="modalCompleteButton">
                            Complete
                        </button>
                    </div>
                </div>
            `;
            
            $('#completionInfo').html(content);
            
            const progressBar = $('#progressBar');
            progressBar
                .removeClass('bg-primary progress-bar-striped progress-bar-animated')
                .addClass(info.verified ? 'bg-success' : 'bg-danger')
                .css('width', '100%');
            
            $('#cancelUpload').addClass('d-none');
            $('#completeButton').addClass('d-none');
            
            // Add click handler for the complete button with Promise resolution
            return new Promise((resolve) => {
                $('#modalCompleteButton').off('click').on('click', async () => {
                    if (confirm('Are you sure you want to return to home?')) {
                        try {
                            // Hide modal first
                            await new Promise(modalResolve => {
                                const modal = bootstrap.Modal.getInstance(document.getElementById('progressModal'));
                                if (modal) {
                                    modal.hide();
                                    // Wait for modal hidden event
                                    $('#progressModal').one('hidden.bs.modal', modalResolve);
                                } else {
                                    modalResolve();
                                }
                            });
                            
                            resolve();
                            // Navigate after promise resolution
                            window.location.href = '/';
                        } catch (error) {
                            console.error('Error during completion:', error);
                            resolve();
                            window.location.href = '/';
                        }
                    }
                });
            });
            
        } catch (error) {
            console.error('Error showing completion info:', error);
            throw error;
        }
    }
};

// Export the handler
window.modalCompletionHandler = modalCompletionHandler;


project\static\js\modal-handlers\progress-modal.js
==================================================
// modal-handlers/progress-modal.js

const progressModalHandler = {
    showProgressModal(initialMessage = 'Initializing...') {
        console.log('Showing progress modal with message:', initialMessage);
        
        try {
            const progressModal = new bootstrap.Modal(document.getElementById('progressModal'), {
                backdrop: 'static',
                keyboard: false
            });

            // Reset the progress bar state
            $('#progressBar')
                .css('width', '0%')
                .attr('aria-valuenow', 0)
                .removeClass('progress-bar-striped progress-bar-animated bg-danger bg-success')
                .addClass('bg-primary');
            
            // Reset text displays
            $('#progressText').text(initialMessage);
            $('#progressDetails').text('');
            
            // Reset completion info and buttons
            $('#completionInfo').addClass('d-none');
            $('#cancelUpload')
                .removeClass('d-none')
                .prop('disabled', false)
                .show();
            $('#completeButton').addClass('d-none');
            
            // Show the modal
            progressModal.show();
            modalState.state.isProgressModalShown = true;
            modalState.state.isUploading = true;

            // Bind cancel button event handler
            this.bindCancelHandler();

        } catch (error) {
            console.error('Error showing progress modal:', error);
            alert('Error initializing progress display. Please try again.');
        }
    },

    hideProgressModal() {
        console.log('Hiding progress modal');
        try {
            const progressModal = bootstrap.Modal.getInstance(document.getElementById('progressModal'));
            if (progressModal) {
                progressModal.hide();
                modalState.state.isProgressModalShown = false;
                modalState.state.isUploading = false;
            }
        } catch (error) {
            console.error('Error hiding progress modal:', error);
        }
    },

    handleError(error, message) {
        console.error('Error:', error);
        const progressBar = $('#progressBar');
        const cancelButton = $('#cancelUpload');
        const completeButton = $('#completeButton');
        const progressText = $('#progressText');
        const progressDetails = $('#progressDetails');

        // Update UI to show error state
        progressBar
            .removeClass('progress-bar-striped progress-bar-animated bg-primary')
            .addClass('bg-danger')
            .css('width', '100%')
            .attr('aria-valuenow', 100);

        // Show error message
        progressText.text(message || 'An error occurred');
        progressDetails.html(`
            <div class="alert alert-danger">
                <strong>Error Details:</strong><br>
                ${error.message || 'Unknown error occurred'}
            </div>
        `);

        // Update button states
        cancelButton.addClass('d-none');
        completeButton
            .removeClass('d-none')
            .prop('disabled', false)
            .text('Return to Home')
            .off('click')
            .on('click', () => {
                if (confirm('Are you sure you want to return to home?')) {
                    this.hideProgressModal();
                    window.location.href = '/';
                }
            });

        modalState.state.processingStatus = 'error';
        modalState.state.isUploading = false;
    },

    updateProgress(message, progress) {
        console.log('Updating progress:', message, progress);
        
        try {
            const progressBar = $('#progressBar');
            const progressText = $('#progressText');
            const progressDetails = $('#progressDetails');
            const cancelButton = $('#cancelUpload');
            const completeButton = $('#completeButton');

            // Reset classes first
            progressBar.removeClass('progress-bar-striped progress-bar-animated bg-danger bg-success bg-primary');

            switch(progress) {
                case 'calculating':
                case 'verifying':
                case 'processing':
                    progressBar
                        .addClass('progress-bar-striped progress-bar-animated bg-primary')
                        .css('width', '100%')
                        .attr('aria-valuenow', 100);
                    progressDetails.text('');
                    cancelButton.prop('disabled', false).show();
                    break;

                case 'cancelled':
                    // Don't automatically hide modal or redirect
                    progressBar
                        .addClass('bg-warning')
                        .css('width', '100%')
                        .attr('aria-valuenow', 100);
                    progressText.text('Upload cancelled');
                    progressDetails.html(`
                        <div class="alert alert-warning">
                            Upload cancelled by user. Click "Return to Home" when ready.
                        </div>
                    `);
                    cancelButton.addClass('d-none');
                    completeButton
                        .removeClass('d-none')
                        .text('Return to Home')
                        .off('click')
                        .on('click', () => {
                            if (confirm('Are you sure you want to return to home?')) {
                                this.hideProgressModal();
                                window.location.href = '/';
                            }
                        });
                    modalState.state.processingStatus = 'cancelled';
                    modalState.state.isUploading = false;
                    break;

                case 'failed':
                case 'error':
                    this.handleError(new Error(message), message);
                    break;

                default:
                    if (typeof progress === 'number') {
                        modalState.state.currentProgress = progress;
                        progressBar
                            .addClass('bg-primary')
                            .css('width', `${Math.round(progress)}%`)
                            .attr('aria-valuenow', Math.round(progress));
                        progressText.text(`${message} ${Math.round(progress)}%`);
                        progressDetails.text('');
                        cancelButton.prop('disabled', false).show();
                    }
            }
        } catch (error) {
            console.error('Error updating progress display:', error);
            this.handleError(error, 'Error updating progress display');
        }
    },

    bindCancelHandler() {
        $('#cancelUpload').off('click').on('click', async (e) => {
            e.preventDefault();
            console.log('Cancel button clicked');
            
            if (!confirm('Are you sure you want to cancel the upload?')) {
                return;
            }
            
            const button = $('#cancelUpload');
            button.prop('disabled', true);
            
            try {
                if (!modalState.state.isUploading) {
                    console.log('No active upload to cancel');
                    return;
                }

                this.updateProgress('Cancelling upload...', 'calculating');
                
                if (!window.fileProcessing) {
                    throw new Error('File processing system not initialized');
                }

                await window.fileProcessing.cancelUpload();
                console.log('Upload cancelled successfully');
                
                this.updateProgress('Upload cancelled', 'cancelled');
                modalState.state.isUploading = false;
                
            } catch (error) {
                console.error('Error cancelling upload:', error);
                this.handleError(error, 'Error cancelling upload: ' + error.message);
            } finally {
                button.prop('disabled', false);
            }
        });
    },

    showCompletionInfo(info) {
        console.log('Showing completion info:', info);
        try {
            $('#completionInfo').removeClass('d-none');
            
            const content = `
                <div class="completion-details p-3">
                    <h4 class="text-center mb-3">Processing Complete</h4>
                    
                    <div class="mb-2">
                        <strong>Original Filename:</strong> ${info.originalFilename}
                    </div>
                    
                    <div class="mb-2">
                        <strong>New Filename:</strong> ${info.newFilename}
                    </div>
                    
                    <div class="mb-2">
                        <strong>File Path:</strong> ${info.filePath || 'N/A'}
                    </div>
                    
                    <div class="mb-2">
                        <strong>Original Hash:</strong> 
                        <span class="font-monospace">${info.originalHash}</span>
                    </div>
                    
                    <div class="mb-2">
                        <strong>New Hash:</strong> 
                        <span class="font-monospace">${info.newHash}</span>
                    </div>

                    <div class="mb-2">
                        <strong>File Size:</strong> ${utils.formatFileSize(info.fileSize)}
                    </div>
                    
                    <div class="text-center mt-3">
                        <span class="badge ${info.verified ? 'bg-success' : 'bg-danger'} p-2">
                            ${info.verified ? 'Verification Successful' : 'Verification Failed'}
                        </span>
                    </div>

                    ${info.processingErrors.length > 0 ? `
                        <div class="mt-3 text-danger">
                            <strong>Errors:</strong>
                            <ul>
                                ${info.processingErrors.map(error => `<li>${error}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    <div class="text-center mt-3">
                        <button type="button" class="btn btn-primary" id="modalCompleteButton">
                            Return to Home
                        </button>
                    </div>
                </div>
            `;
            
            $('#completionInfo').html(content);
            
            const progressBar = $('#progressBar');
            progressBar
                .removeClass('bg-primary progress-bar-striped progress-bar-animated')
                .addClass(info.verified ? 'bg-success' : 'bg-danger')
                .css('width', '100%');
            
            $('#cancelUpload').addClass('d-none');
            $('#completeButton').addClass('d-none');
            
            // Add click handler for the complete button
            $('#modalCompleteButton').off('click').on('click', () => {
                if (confirm('Are you sure you want to return to home?')) {
                    this.hideProgressModal();
                    window.location.href = '/';
                }
            });
            
        } catch (error) {
            console.error('Error showing completion info:', error);
            this.handleError(error, 'Error displaying completion information');
        }
    }
};

// Export the handler
window.progressModalHandler = progressModalHandler;


project\static\js\modal-handlers\state.js
=========================================
// modal-handlers/state.js
const modalState = {
    state: {
        isProgressModalShown: false,
        isConfirmationModalShown: false,
        currentProgress: 0,
        processingStatus: null,
        isUploading: false
    },

    resetState() {
        this.state = {
            isProgressModalShown: false,
            isConfirmationModalShown: false,
            currentProgress: 0,
            processingStatus: null,
            isUploading: false
        };
    }
};


project\static\js\modules\app-state.js
======================================
// app-state.js
const appState = {
    isUploading: false,
    currentUpload: null,
    currentFolder: null,
    lastError: null,
    initialized: false,

    setUploading(status) {
        this.isUploading = status;
    },

    setCurrentUpload(upload) {
        this.currentUpload = upload;
    },

    setCurrentFolder(folder) {
        this.currentFolder = folder;
    },

    setError(error) {
        this.lastError = error;
    },

    setInitialized(status) {
        this.initialized = status;
    },

    reset() {
        this.isUploading = false;
        this.currentUpload = null;
        this.currentFolder = null;
        this.lastError = null;
    }
};


project\static\js\modules\config.js
===================================
// config.js
const config = {
    state: {
        fileSaveLocation: null,
        maxFileSizeGB: null,
        systemName: null,
        initialized: false
    },

    async initialize() {
        try {
            const response = await fetch('/config');
            if (!response.ok) {
                throw new Error('Failed to fetch configuration');
            }
            const config = await response.json();
            
            this.state.fileSaveLocation = config.UPLOAD_FOLDER;
            this.state.maxFileSizeGB = config.MAX_FILE_SIZE / (1024 * 1024 * 1024);
            this.state.systemName = config.SYSTEM_NAME;
            this.state.initialized = true;
            
            return this.state;
        } catch (error) {
            console.error('Error initializing configuration:', error);
            throw error;
        }
    },

    get isInitialized() {
        return this.state.initialized;
    }
};


project\static\js\modules\event-handlers.js
===========================================
// event-handlers.js
const eventHandlers = {
    initialize() {
        console.log('Initializing event handlers...');
        
        this.bindPreFillHandler();
        this.bindFileInputHandler();
        this.bindFormFieldHandlers();
        this.bindRenameCheckboxHandler();
        this.bindSubmitButtonHandler();
        this.bindConfirmSubmitHandler();
        this.bindConfirmationCheckboxesHandler();
        this.bindCancelHandlers();
        this.bindSecretSequenceHandler();
        
        console.log('Event handlers initialized successfully');
    },

    bindPreFillHandler() {
        $('#preFill').off('click').on('click', function(e) {
            console.log('Pre-fill button clicked');
            e.preventDefault();
            
            $('#operation').val('Sample Operation');
            $('#deviceType').val('unknown');
            $('#serialNumber').val('12345');
            $('#itemNumber').val('001');
            $('#subNumber').val('1');
            $('#collection').val('unknown');
            $('#platform').val('unknown');
            $('#knownPasswords').val('password1,password2');
            $('#notes').val('Sample notes for data ingestion.');
            $('#processingMethod').val('Normal');
            
            fileRenaming.updateRenamePreview();
        });
    },

    bindFileInputHandler() {
        $('#selectFile').off('change').on('change', function() {
            console.log('File input changed');
            const fileInput = $(this)[0];
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                $('#fileName').val(file.name);
                $('#fileSize').text(utils.formatFileSize(file.size));
                fileRenaming.updateRenamePreview();
                formValidator.checkFileSize(file);
            } else {
                $('#fileName').val('');
                $('#fileSize').text('');
                $('#fileSizeMessage').text(`Maximum upload size is ${config.state.maxFileSizeGB} GB`);
            }
        });
    },

    bindFormFieldHandlers() {
        $('#operation, #itemNumber, #subNumber, #deviceType, #dateOfCollection')
            .off('input change')
            .on('input change', function() {
                console.log('Form field changed:', this.id);
                fileRenaming.updateRenamePreview();
            });
    },

    bindRenameCheckboxHandler() {
        $('#renameFileCheck').off('change').on('change', function() {
            console.log('Rename checkbox changed:', this.checked);
            fileRenaming.updateRenamePreview();
        });
    },

    bindSubmitButtonHandler() {
        $('#openConfirmationModal').off('click').on('click', function(e) {
            console.log('Open confirmation modal clicked');
            e.preventDefault();
            
            if (!formValidator.validateForm()) {
                return;
            }

            fileRenaming.updateRenamePreview();
            modalHandlers.populateConfirmationModal();
            modalHandlers.showConfirmationModal();
        });
    },

    bindConfirmSubmitHandler() {
        $('#confirmSubmit').off('click').on('click', async function(e) {
            e.preventDefault();
            console.log('Confirm submit clicked');
            
            const fileInput = $('#selectFile')[0];
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file');
                return;
            }

            try {
                // Generate folder name and set it
                const folderName = fileRenaming.generateFolderName();
                window.fileProcessing.setCurrentFolderName(folderName);
                appState.setCurrentFolder(folderName);

                // Gather metadata from form
                const metadata = submissionHandler.gatherFormMetadata(file, folderName);
                console.log('Submitting with metadata:', metadata);

                // Process the submission
                await submissionHandler.handleFormSubmission(file, metadata);

            } catch (error) {
                console.error('Form submission error:', error);
                modalHandlers.updateProgress('Error: ' + error.message, 'error');
            }
        });
    },

    bindConfirmationCheckboxesHandler() {
        $(document).off('change', '.review-checkbox').on('change', '.review-checkbox', function() {
            console.log('Review checkbox changed');
            const totalCheckboxes = $('.review-checkbox').length;
            const checkedCheckboxes = $('.review-checkbox:checked').length;
            const allChecked = totalCheckboxes > 0 && checkedCheckboxes === totalCheckboxes;
            
            console.log(`Checkboxes: ${checkedCheckboxes}/${totalCheckboxes}`);
            $('#confirmSubmit').prop('disabled', !allChecked);
        });
    },

    bindCancelHandlers() {
        // Cancel review handler
        $('#cancelReview').off('click').on('click', function() {
            console.log('Cancel review clicked');
            modalHandlers.hideConfirmationModal();
        });

        // Cancel upload handler
        $('#cancelUpload').off('click').on('click', function() {
            console.log('Cancel upload clicked');
            if (window.fileProcessing.getCurrentUpload()) {
                modalHandlers.updateProgress('Cancelling upload...', 'calculating');
                window.fileProcessing.getCurrentUpload().abort();
            }
        });

        // Complete button handler
        $('#completeButton').off('click').on('click', function() {
            console.log('Complete button clicked');
            modalHandlers.hideProgressModal();
            appState.setUploading(false);
        });
    },

    bindSecretSequenceHandler() {
        let secretSequence = '';
        $(document).off('keypress').on('keypress', function(e) {
            secretSequence += String.fromCharCode(e.which);
            if (secretSequence.endsWith('xxx')) {
                console.log('Secret sequence activated!');
                $('.review-checkbox').prop('checked', true);
                
                const totalCheckboxes = $('.review-checkbox').length;
                const checkedCheckboxes = $('.review-checkbox:checked').length;
                const allChecked = totalCheckboxes > 0 && checkedCheckboxes === totalCheckboxes;
                
                $('#confirmSubmit').prop('disabled', !allChecked);
                secretSequence = '';
            }
            if (secretSequence.length > 10) {
                secretSequence = '';
            }
        });
    },

    verifyHandlers() {
        // Verify that all crucial handlers are bound
        const criticalElements = [
            '#preFill',
            '#selectFile',
            '#renameFileCheck',
            '#openConfirmationModal',
            '#confirmSubmit',
            '#cancelReview',
            '#cancelUpload',
            '#completeButton'
        ];

        criticalElements.forEach(selector => {
            const element = $(selector);
            if (element.length === 0) {
                console.error(`Critical element not found: ${selector}`);
            } else {
                console.log(`Handler verified for: ${selector}`);
            }
        });
    }
};

// Make eventHandlers available globally
window.eventHandlers = eventHandlers;


project\static\js\modules\file-renaming.js
==========================================
// file-renaming.js
const fileRenaming = {
    updateRenamePreview() {
        console.log('Updating rename preview');
        const operation = $('#operation').val().replace(/\s+/g, '_');
        const itemNumber = $('#itemNumber').val();
        const subNumber = $('#subNumber').val();
        const deviceType = $('#deviceType').val();
        const collectionDate = $('#dateOfCollection').val();
        const fileInput = $('#selectFile')[0];
        let fileExtension = '';

        if (fileInput.files.length > 0) {
            const fileName = fileInput.files[0].name;
            const lastDotIndex = fileName.lastIndexOf('.');
            if (lastDotIndex !== -1) {
                fileExtension = fileName.substring(lastDotIndex);
            }
        }

        const renamePreview = `${operation}_${itemNumber}-${subNumber}_${deviceType}_${collectionDate}${fileExtension}`;
        console.log('New rename preview:', renamePreview);
        $('#renamePreview').val(renamePreview);
    },

    generateFolderName() {
        const renamePreview = $('#renamePreview').val();
        const currentTime = new Date().toLocaleTimeString('en-US', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit' 
        }).replace(':', '');
        
        return `${renamePreview.split('.')[0]}_${currentTime}`;
    }
};



project\static\js\modules\form-validator.js
===========================================
// form-validator.js
const formValidator = {
    checkFileSize(file) {
        const fileSizeInGB = file.size / (1024 * 1024 * 1024);
        const fileSizeMessage = $('#fileSizeMessage');
        const maxFileSizeGB = config.state.maxFileSizeGB;
        
        if (fileSizeInGB > maxFileSizeGB) {
            fileSizeMessage
                .text(`File is too large. Maximum size is ${maxFileSizeGB} GB. Your file is ${fileSizeInGB.toFixed(2)} GB.`)
                .addClass('text-danger');
            $('#selectFile').val('');
            $('#fileName').val('');
            $('#fileSize').text('');
            return false;
        } else {
            fileSizeMessage
                .text(`File size: ${utils.formatFileSize(file.size)} (Max: ${maxFileSizeGB} GB)`)
                .removeClass('text-danger');
            return true;
        }
    },

    validateForm() {
        const fileInput = $('#selectFile')[0];
        if (!fileInput.files.length) {
            alert('Please select a file first');
            return false;
        }
        return true;
    }
};



project\static\js\modules\main.js
=================================
// main.js
$(document).ready(async function() {
    console.log('Document ready, initializing application...');
    
    try {
        // Initialize configuration
        await config.initialize();
        
        // Initialize form fields
        $('#processingMethod').val('Normal');
        $('#dateOfCollection').val(new Date().toISOString().split('T')[0]);
        
        // Verify system state
        if (!window.fileProcessing) {
            throw new Error('File processing system not initialized');
        }
        if (!window.modalHandlers) {
            throw new Error('Modal handlers not initialized');
        }
        
        // Initialize event handlers
        eventHandlers.initialize();
        
        // Set application as initialized
        appState.setInitialized(true);
        console.log('Application initialized successfully');
        
    } catch (error) {
        console.error('Error initializing application:', error);
        alert('Failed to initialize application. Please refresh the page or contact administrator.');
    }
});

// Export global utilities
window.appState = appState;
window.config = config;
window.formValidator = formValidator;
window.fileRenaming = fileRenaming;
window.submissionHandler = submissionHandler;
window.eventHandlers = eventHandlers;


project\static\js\modules\submission-handler.js
===============================================
// modules/submission-handler.js
const submissionHandler = {
    async handleFormSubmission(file, metadata) {
        try {
            // Hide confirmation modal and show progress modal
            modalHandlers.hideConfirmationModal();
            modalHandlers.showProgressModal('Initializing upload...');
            appState.setUploading(true);
            
            // Validate file and metadata
            if (!file || !metadata) {
                modalHandlers.updateProgress('Invalid file or metadata provided', 'error');
                return;
            }

            // Start file processing
            const result = await window.fileProcessing.processFile(file, metadata);
            
            // Handle processing result
            if (!result || !result.success) {
                const errorMessage = result?.error || 'Unknown processing error occurred';
                console.error('Processing failed:', errorMessage);
                modalHandlers.updateProgress(errorMessage, 'error');
                return;
            }
            
            // Successfully completed
            modalHandlers.updateProgress('Processing complete', 'success');
            appState.setUploading(false);
            
            // Show completion info if available
            if (result.filePath && result.originalFilename) {
                modalHandlers.showCompletionInfo({
                    originalFilename: result.originalFilename,
                    newFilename: result.newFilename || result.originalFilename,
                    filePath: result.filePath,
                    originalHash: result.originalHash,
                    newHash: result.newHash,
                    fileSize: file.size,
                    verified: result.verified,
                    processingErrors: []
                });
            }

            return result;
        } catch (error) {
            console.error('Submission error:', error);
            this.handleProcessingError(error);
        }
    },

    handleProcessingError(error) {
        console.error('Processing error details:', error);
        
        // Update application state
        appState.setError(error);
        appState.setUploading(false);

        // Handle different error types
        if (error.name === 'AbortError') {
            console.log('Upload was cancelled by user');
            modalHandlers.updateProgress('Upload cancelled by user', 'cancelled');
        } else {
            // Determine error message
            let errorMessage = 'An error occurred during processing';
            if (error.message) {
                errorMessage = error.message;
            } else if (typeof error === 'string') {
                errorMessage = error;
            }

            // Update modal with error
            modalHandlers.updateProgress(errorMessage, 'error');
        }
    },

    gatherFormMetadata(file, folderName) {
        return {
            original_filename: file.name,
            new_filename: $('#renameFileCheck').is(':checked') ? $('#renamePreview').val() : "",
            rename_file: $('#renameFileCheck').is(':checked'),
            operation: $('#operation').val(),
            deviceType: $('#deviceType').val(),
            serialNumber: $('#serialNumber').val(),
            itemNumber: $('#itemNumber').val(),
            subNumber: $('#subNumber').val(),
            collection: $('#collection').val(),
            platform: $('#platform').val(),
            dateOfCollection: $('#dateOfCollection').val(),
            knownPasswords: $('#knownPasswords').val(),
            notes: $('#notes').val(),
            processingMethod: $('#processingMethod').val(),
            approved: 'No',
            system: config.state.systemName,
            folder_name: folderName,
            timestamp: new Date().toISOString(),
            fileSize: file.size
        };
    },

    validateSubmission(file, metadata) {
        const errors = [];

        if (!file) {
            errors.push('No file selected');
        }

        if (!metadata.operation) {
            errors.push('Operation name is required');
        }

        if (!metadata.dateOfCollection) {
            errors.push('Date of collection is required');
        }

        return {
            valid: errors.length === 0,
            errors: errors
        };
    }
};

// Make submissionHandler available globally
window.submissionHandler = submissionHandler;


project\templates\404.html
==========================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 Not Found</title>
</head>
<body>
    <h1>404 Not Found</h1>
    <p>The requested page could not be found. Please check the URL and try again.</p>
    <a href="{{ url_for('client_app.main_routes.home') }}">Return to Home</a>
</body>
</html>


project\templates\500.html
==========================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>500 Internal Server Error</title>
</head>
<body>
    <h1>500 Internal Server Error</h1>
    <p>The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>
</body>
</html>


project\templates\base.html
===========================
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{% block title %}Client App{% endblock %}</title>

        <link href="{{ url_for('static', filename='css/bootstrap.min.css') }}" rel="stylesheet">
        <link href="{{ url_for('static', filename='css/custom.css') }}" rel="stylesheet">
        
        {% block extra_head %}{% endblock %}
    </head>
<body>
    <!-- Classification bar -->
    <div class="bg-primary text-white p-2 text-center w-100"><strong>Classification Bar</strong></div>

    <!-- Notice bar -->
    <div class="bg-danger text-white p-2 text-center w-100" style="font-weight: bold; height: 40px; line-height: 40px; display: flex; align-items: center; justify-content: center;">
        Notice Bar: User Notices Here
    </div>

    <!-- Centered Navigation Menu -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light justify-content-center">
        <ul class="navbar-nav">
            <li class="nav-item">
                <a class="nav-link" href="{{ url_for('client_app.main_routes.home') }}">Home</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="{{ url_for('client_app.main_routes.history') }}">History</a>
            </li>
        </ul>
    </nav>

    <div class="container mt-4">
        {% block content %}{% endblock %}
    </div>

    <!-- Core JavaScript Dependencies -->
    {% block scripts %}
    <script src="{{ url_for('static', filename='js/lib/jquery/jquery-3.6.0.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/lib/bootstrap/bootstrap.bundle.min.js') }}"></script>
    {% endblock %}
</body>
</html>


project\templates\history.html
==============================
{% extends "base.html" %}

{% block title %}History{% endblock %}

{% block extra_head %}
<link href="{{ url_for('static', filename='css/history.css') }}" rel="stylesheet">
{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2 class="text-center mb-4">History</h2>

    <!-- Search Box - Fallback to Bootstrap version until React is fully set up -->
    <div class="mb-4 position-relative">
        <input 
            type="text" 
            id="searchBox" 
            class="form-control py-2 ps-4" 
            placeholder="   Search metadata..."
            style="padding-left: 2.5rem;"
        >
        <div class="position-absolute" style="left: 0.75rem; top: 50%; transform: translateY(-50%);">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="text-muted" viewBox="0 0 16 16">
                <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
            </svg>
        </div>
    </div>

    <!-- Folder List -->
    <div id="folderList"></div>

    <!-- Info Modal -->
    <div class="modal fade" id="infoModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">File Information</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="infoContent"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Inventory Modal -->
    <div class="modal fade" id="inventoryModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Chunk Inventory</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="inventoryContent"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal Root -->
    <div id="deleteModalRoot"></div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script src="{{ url_for('static', filename='js/handlers/delete-handlers.js') }}"></script>
<script src="{{ url_for('static', filename='js/handlers/history-handlers.js') }}"></script>
{% endblock %}


project\templates\home.html
===========================
{% extends "base.html" %}

{% block title %}Data Ingestion Client Panel{% endblock %}

{% block content %}
    <!-- Review Modal -->
    <div class="modal fade" id="confirmationModal" tabindex="-1" aria-labelledby="confirmationModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="confirmationModalLabel">Review Data Ingestion Request</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Please review your submission before proceeding:</p>
                    <div class="table-responsive">
                        <table class="table table-bordered confirmation-table">
                            <thead>
                                <tr>
                                    <th>Field</th>
                                    <th class="from-value">Value</th>
                                    <th class="reviewed-column">Reviewed</th>
                                </tr>
                            </thead>
                            <tbody id="confirmationTableBody">
                                <!-- Rows will be dynamically added by script.js -->
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelReview" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmSubmit" disabled>Submit</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Progress Modal -->
    <div class="modal fade" id="progressModal" tabindex="-1" aria-labelledby="progressModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="progressModalLabel">File Processing</h5>
                </div>
                <div class="modal-body">
                    <div class="progress mb-3">
                        <div id="progressBar" class="progress-bar bg-primary" role="progressbar" 
                             style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                        </div>
                    </div>
                    <p id="progressText" class="mb-2">Initializing...</p>
                    <p id="progressDetails" class="small text-muted"></p>
                    
                    <!-- Completion Information (initially hidden) -->
                    <div id="completionInfo" class="mt-4 d-none">
                        <!-- Content will be dynamically populated -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger" id="cancelUpload">Cancel</button>
                    <button type="button" class="btn btn-success d-none" id="completeButton">Complete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container mt-4">
        <h2 class="text-center mb-4">Data Ingestion Client Panel</h2>
        
        <div class="card shadow-lg">
            <div class="card-body">
                <form id="dataIngestionForm">
                    <!-- File Selection -->
                    <div class="mb-4">
                        <input type="file" class="form-control" id="selectFile" name="file">
                        <small id="fileSizeMessage" class="form-text text-muted"></small>
                    </div>

                    <!-- Pre-fill Button -->
                    <div class="mb-4 text-center">
                        <button type="button" class="btn btn-secondary" id="preFill">Pre-fill Form</button>
                    </div>

                    <!-- Operation -->
                    <div class="mb-4">
                        <label for="operation" class="form-label">Operation</label>
                        <input type="text" class="form-control" id="operation" name="operation" required>
                    </div>

                    <!-- File Information Section -->
                    <div class="card mb-4">
                        <div class="card-header">
                            <h5 class="mb-0">File Information</h5>
                        </div>
                        <div class="card-body">
                            <div class="row g-3">
                                <div class="col-md-2">
                                    <label for="fileSelectCheck" class="form-label">Select</label>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="fileSelectCheck" checked>
                                        <label class="form-check-label" for="fileSelectCheck">Selected</label>
                                    </div>
                                </div>
                                
                                <div class="col-md-4">
                                    <label for="fileName" class="form-label">File Name</label>
                                    <input type="text" class="form-control" id="fileName" name="file_name" readonly>
                                    <small id="fileSize" class="form-text text-muted"></small>
                                </div>
                                
                                <div class="col-md-2">
                                    <label for="deviceType" class="form-label">Device Type</label>
                                    <select class="form-select" id="deviceType" name="device_type" required>
                                        <option value="laptop">Laptop</option>
                                        <option value="phone">Phone</option>
                                        <option value="tablet">Tablet</option>
                                        <option value="other">Other</option>
                                        <option value="unknown">Unknown</option>                         
                                    </select>
                                </div>
                                
                                <div class="col-md-2">
                                    <label for="serialNumber" class="form-label">Serial No</label>
                                    <input type="text" class="form-control" id="serialNumber" name="serial_number">
                                </div>
                                
                                <div class="col-md-1">
                                    <label for="itemNumber" class="form-label">Item No</label>
                                    <input type="text" class="form-control" id="itemNumber" name="item_number" value="001">
                                </div>
                                
                                <div class="col-md-1">
                                    <label for="subNumber" class="form-label">Sub No</label>
                                    <input type="text" class="form-control" id="subNumber" name="sub_number" value="1">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Additional Information -->
                    <div class="row g-3 mb-4">
                        <div class="col-md-6">
                            <label for="collection" class="form-label">Collection</label>
                            <select class="form-select" id="collection" name="collection" required>
                                <option value="red">Red</option>
                                <option value="blue">Blue</option>
                                <option value="green">Green</option>
                                <option value="unknown">Unknown</option>
                            </select>
                        </div>
                        
                        <div class="col-md-6">
                            <label for="platform" class="form-label">Platform</label>
                            <select class="form-select" id="platform" name="platform" required>
                                <option value="windows">Windows</option>
                                <option value="macos">MacOS</option>
                                <option value="linux">Linux</option>
                                <option value="unknown">Unknown</option>
                            </select>
                        </div>
                    </div>

                    <!-- Date and Passwords -->
                    <div class="row g-3 mb-4">
                        <div class="col-md-6">
                            <label for="dateOfCollection" class="form-label">Date of Collection</label>
                            <input type="date" class="form-control" id="dateOfCollection" name="date_of_collection" required>
                        </div>
                        
                        <div class="col-md-6">
                            <label for="knownPasswords" class="form-label">Known Passwords (comma-separated)</label>
                            <input type="text" class="form-control" id="knownPasswords" name="known_passwords">
                        </div>
                    </div>

                    <!-- Notes -->
                    <div class="mb-4">
                        <label for="notes" class="form-label">Notes</label>
                        <textarea class="form-control" id="notes" name="notes" rows="3"></textarea>
                    </div>

                    <!-- File Rename Section -->
                    <div class="card mb-4">
                        <div class="card-header">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="renameFileCheck">
                                <label class="form-check-label" for="renameFileCheck">
                                    Rename File
                                </label>
                            </div>
                        </div>
                        <div class="card-body">
                            <label for="renamePreview" class="form-label">File Name Preview</label>
                            <input type="text" class="form-control" id="renamePreview" readonly>
                        </div>
                    </div>

                    <!-- Processing Method -->
                    <div class="mb-4">
                        <label for="processingMethod" class="form-label">Processing Method</label>
                        <select class="form-select" id="processingMethod" name="processingMethod" required>
                            <option value="Normal">Normal</option>
                            <option value="MX Pipeline">MX Pipeline</option>
                            <option value="Manual on PN03">Manual on PN03</option>
                            <option value="Manual on PN04">Manual on PN04</option>
                        </select>
                    </div>

                    <!-- Submit Button -->
                    <div class="text-center">
                        <button type="button" class="btn btn-primary btn-lg" id="openConfirmationModal">Submit</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    <!-- jQuery -->
    <script src="{{ url_for('static', filename='js/lib/jquery/jquery-3.6.0.min.js') }}"></script>
    
    <!-- Bootstrap Bundle -->
    <script src="{{ url_for('static', filename='js/lib/bootstrap/bootstrap.bundle.min.js') }}"></script>
    
    <!-- Core utils -->
    <script src="{{ url_for('static', filename='js/core/utils.js') }}"></script>
    
    <!-- Application Modules -->
    <script src="{{ url_for('static', filename='js/modules/config.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modules/app-state.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modules/form-validator.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modules/file-renaming.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modules/submission-handler.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modules/event-handlers.js') }}"></script>
    
    <!-- Handlers -->
    <script src="{{ url_for('static', filename='js/modal-handlers/state.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modal-handlers/progress-modal.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modal-handlers/confirmation-modal.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modal-handlers/modal-completion.js') }}"></script>
    <script src="{{ url_for('static', filename='js/modal-handlers/index.js') }}"></script>
    <script src="{{ url_for('static', filename='js/handlers/form-handlers.js') }}"></script>
    
    <!-- Processing Scripts -->
    <script src="{{ url_for('static', filename='js/chunked-upload.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/state.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/hash-calculator.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/uploader.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/cancellation-handler.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/error-handler.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/completion-handler.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/processor.js') }}"></script>
    <script src="{{ url_for('static', filename='js/file-processing/index.js') }}"></script>
    
    <!-- Main Script -->
    <script src="{{ url_for('static', filename='js/modules/main.js') }}"></script>
{% endblock %}

